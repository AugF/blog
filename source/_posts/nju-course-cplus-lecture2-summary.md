---
title: nju-course-cplus-lecture2-summary
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 09:47:59
tags:
- nju
- course
- cplus
categories:
- [course, nju, cplus]
---
重点

1. 抽象和封装
> 抽象是外，封装是里；为什么好？栈举例，直接来，没有函数封装；结构体+函数封装，数据隐私问题，成员仍可被破坏。

一个重要的问题：加访问控制 public, private(默认),protected

面向对象：类型和对象。程序若干个对象。对象之间关系，一是继承，传承特征；对象之间靠接口，公有函数的参数或友元来维持关系。

设计几大理念：
1. 抽象，控制住底层的复杂度
2. 封装，同上，侧重隐藏信息
3. 模块化，抽象封装是单个，模块化则是对整个而言
4. 软件复用：可复用的东西变得更多
5. 可维护性：代码框架灵活
6. 软件模型的自然度：能对应于问题空间

面向过程：过程即功能，特定功能集合，没有对象的概念。所有的东西会乱成一团。复用性差，太特殊

2. 面向过程

类型 对象（动态）

系统向一个对象通信(即只调用一个对象的接口).然后不定地解决问题。
> 不过是类的问题。

3. 特性：多态

函数名，类型。

父类对象继承子类: 
子类可以有两个选择
父类指针可以有两个指向
消息可以有多种发送选择

访问控制的建议
内部的东西private, 比如类的数据成员，类内部使用的成员函数。

调用未定义的类，指针+引用

对象，动态和静态、全局和局部。

4. 使用对象
- 赋值
- 参数 const A &
- 返回值
- this
- 对象初始化，常量和引用一般不让初始化
- 构造函数和析构函数对应。
- 成员对象，拷贝构造函数
- 静态成员对象
- f(const Data& d){}, 然后 类的对象就分为两种：获取对象状态 const,外界元素均可访问，也要通过类的对象来操作，不够对应2那种参数可以进行使用；改变对象状态，需要类的对象来进行操作。
> 换言之，是为常量对象而准备的
- 友元，不具有对称性和传递性，可以是类，全局函数或者类的成员函数（都行）。
> 具体时间差没测试。效率上会消失多少？

- 类作为单独的模块，降低耦合。成员函数只向有限个元素发送。

- 作业：用类来实现矩阵和向量类型
矩阵：数据、行数、列数。
外界的获取接口：
- 获得行数和列数，int& element(int x, int y), 这样是否可以通过地址来修改元素的值呢？
`m.element(1,2) = m.element(1,2) + 1`, 不过说到底也是对的啊，进行的是值替代, 而这也是符合引用的定义的啊。
- 操作函数，对元素进行操作
- 构造函数: 对元素和空间进行检查。

> 注意：凡是函数，一定要记得对函数的输入数据进行检查和核对。

向量：数据、维数。

- 附录：补充
> cout与cerr: 几次都遇到这种情况，不过我想今天应该明了。cout是控制台输出，当遇到endl，就不再缓冲，直接把数据输出。
cerr在命令行下，
linux下命令行截取的是cerr, 1>>log输出的是控制台，2>>输出的是错误信息 

> 缓冲，刷新的概念，集中输出，防止刷屏。可以看到缓冲好的数据，生活中有很多这样的例子。比如，电视机显式，等一段画面到来时再显示图像。
> 注意指针和实体数组，对于指针单位长度和数组元素一样。然后，new开辟的空间只能用指针来做。