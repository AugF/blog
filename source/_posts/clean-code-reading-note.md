---
title: 'clean code: reading note'
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-16 16:08:54
tags:
- code
- technology
categories:
- [code, technology]
---

> 由于自己写的代码老是感觉像屎一样烂，所以觉得不学学这方面的东西，真的是自己都看不下去了

代码整洁之道  Rober C.Martin著， 韩磊译 
> 就学习而言，自己尽可能去过了一遍知识点，以下记的内容多半是过细的内容。要真正掌握之， 还需要summary最重要的准则，牢记于大脑中，形成做事的准则。同时，并且还要加以实战，对实例进行了解才是

学习参考代码·
https://github.com/AugF/CleanCode

## A. 概览

1. 什么是整洁代码
    - Bjame (C++)
        > 缺陷难以隐藏；减少依赖；分层战略处理错误代码；性能调至最优；整洁的代码只做好一件事情
    - Grady
        > 干净利落的抽象和直截了当的控制语句
    - Dave Thomas
        > 单元测试和验收测试；明确定义和提供清晰、尽量少的API
    - Ron
        > 消除重复和提高表达力，提早构建简单抽象

2. 重点： !!! 童子军军规：让你的营地比你来时更干净。 每次签入时，都比签出干净
3. 后续阅读： 敏捷软件开发：原则、模式与实践
2. 章节安排
    - 有意义的命名
    - 函数
    - 注释
    - 格式
    - 对象和数据结构
    - 错误处理
    - 单元测试
    - 类
    - 系统
    - 迭进
    - 并发编程
    - 逐步改进
    - JUnit内幕
    - 重构SerialDate
    - 味道与启发 ???

<!-- more -->
## B. 有意义的命名

1. 目标： 名副其实（不需要注释来补充）

2. 注意
    - 避免误导
        1. 与平台相关的词 hp,axis,sco
        2. List等约定中的词
    - 做有意义的区分!
        1. a1, a2, aN 这种拒绝
        2. 英语同义词 Info和Data名称不同，但是意义却差别不大
   - 避免使用编码
        > 匈牙利算法和成员前缀都不推荐; 一个例子，接口和实现，必须需要来表明一个，可以实现用XXXImpl
    - 避免思维映射
        > 思维映射就是不要占用读着已经很熟知的名词
    - 别扮可爱
    - 别用双关语(如add)
    
3. 具体操作
    - 具体
        - 类名和对象名都应该是名词，或者名词性结构，如a+n. 
        - 方法名，动词或动词短语，属性访问器get， 修改器set 和 断言 is
            > 建议： 构造器使用参数的静态工厂方法
     - 使用读的出来的名称
        > 避免使用的简写很难反映出来
    - 使用可搜索出来的变量
        > 当某个变量具有某种特别的用意的时候，避免使用常见单词，难以搜索的。比如，0表示START状态，那么就用START，不要用0
    - 使用解决方案领域名称， 比如具体的代码实现部分，JobQueue, AccountVisitor访问者模式
    - 添加有意义的语境，也不要添加没用的语境， 变量搁在一块时，应该是具有某种含义的。
        > 就是语境划分得越明确越清楚
    - 每个抽象概念对应于一个词, 如controller, driver等词是重复的
4. 良好的英语水平

## C. 函数

1. 函数的第一规则是短小，第二规则是更短小
> 24行， 80列
2. 只做一件事
3. 函数内容的组织
    - 每个部分都应该是To do; 1. 2.  3. 
    - 使用描述性的名称，命名方式保持一致
    - 函数参数，最优为零参数，然后一参数。
        > 对参数考虑，转换为类；对于二参数，抽象为类的成员变量
    - 动词与关键字，函数的名字应该能很好地解释函数的意图
    - 分隔指令与询问，要么做什么事，要么回答什么事
    - 避免使用错误码
    - 抽离try/catch 代码块，try，catch单独封装函数
    - 别重复自己
    - 结构化编程，函数应该有统一的样子，入口和出口应该标准化

4. 每个系统都是使用某种领域特定语言搭建，而这种语言是程序设计来描述那个系统的。函数是语言的动词，类是名词。

大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程的工具构建一种更为丰富且更具表达力的语言。

## D. 注释

能用重构代码来解决的事情，就不要考虑用注释来做

1. 注释不能美化糟糕的代码；糟糕的代码最后进行重构
2. 好注释， 应该能提供基本的信息
    - 解释了某个对象的返回值
    - 对意图的解释， 为什么做这步决定
    - 将复杂的代码用简单易懂的形式进行阐释
    - 警示可能发生的严重的后果
    - todo注释应该解释为什么该函数的实现无所作为，将来应该是怎样
    - 用于强调，强调某件事情的重要性
    - 标记注释 while, for的结束也是可以的
    
3. 公共库JavaDoc可能也有误导、不适用或者提供错误信息

4. 坏注释
    - 喃喃自语，看不懂
    - 太显然，多余的注释
    - 误导性注释
    - 日志式注释，交给版本管理系统去解决
    - 废话注释
    - 注释掉的代码！！ 最没有用的，时间越长越不好
    - 位置标记，可以用，用完请清除
    - HTML注释，标记太耀眼
    - 信息不要过多
    - 联系不紧密的注释

5. 建议
    - 能用函数或变量时就别用注释， 如 if(smodule.getDependSubsystems().contains(susSysMod.getSubSystem))
    - 短函数不要太多描述，到不如给它起个好的名字
    - 注释一定要放在离他最近的位置
    - 非公共用途代码没有必要用Javadoc模板
    
如果注释都还需要解释的话，一定不是个好注释
能够通过看注释而省去看代码的时间就是好的注释

## E. 格式

代码的格式对于代码的可读性非常重要。

> 一个好的格式最重要的其实就是能够满足人们从上到下很自然地阅读。自然地能够获取到整体的内容。

向报纸学习，看报纸时常常是从上到下阅读。在顶部，期望有个头条，告诉你故事主线决定是否阅读下去。第一段是故事的大纲，给出粗线条描述。接着读下去，细节渐次增加。

1. 垂直格式
    1. 垂直分隔
        > 概念上的垂直分隔，封包声明、导入声明、每个函数之间应该都有空白行处理
        > ? 某个函数内的逻辑是否需要用空格区分开来
        > 实际上看到的就是一个代码组
    2. 垂直方向的靠近
        > 空白行隔开了概念，靠近的代码行暗示它们之间的关系
        - 临时变量应该放在最适合的位置
    3. 垂直距离
        - 变量声明：变量声明应该尽可能靠近使用位置
        - 循环中的循环变量应该总是在循环语句中声明
        - 实体变量应该在统一的位置声明，或顶部
        - 相关函数 调用者应该在被调用者的上面
        - 概念相关的代码应该放在一起，比如同名函数

2. 横向格式
    - 建议80到120个字符，应该一个屏幕宽度能够阅读.
    - 使用空格字符将彼此紧密相关的连接在一起，也用空格字符将相关性较弱的事务分割开，比如在赋值符左右加空格，其实是为了强调赋值操作有两个确定的要素：左边和右边； 不在函数名和左圆括号之间加控股个，因为函数与其参数紧密相关
    - 空格字符的另一个用法就是强调其前面的字符
    - 水平不对齐
    - 缩进： 整个文件、文件中的类、类的方法、方法中的代码块、代码块中的代码组

遵循团队规则！！！

## F. 对象和数据结构

1. 不愿以抽象形态表述数据
2. 数据、对象的反对称性：
    - 对象把数据隐藏于抽象之后，暴露操作数据的函数。数
    - 数据结构暴露其数据，没有提供有意义的函数

3. 过程式代码 vs 面向对象式代码
    - 过程式代码（使用数据结构的代码）便于在不改动现有数据结构的前提下添加新函数
    - 面向对象代码便于在不该懂即有函数的情况下添加新类

4. The Law of Demeter:
    > 模块不应该了解它所操作对选哪个的内部情况。
    
    类C的方法f只应该调用以下对象的方法 ?（第二次看到，还是不够理解）
    - C
        > C本身的函数和方法? 这里看起来是非常模糊的
    - 由f创建的对象
        > C中所拥有的的临时变量?
    - 作为参数传递给f的对象
        > 即参数
    - 由C的实体变量持有的对象
        > C的成员 
    
    > 一个违反的例子： final String outputDir=ctxt.getOptions().getScratchDir().getAbsolutePath(); 这个例子叫做火车失事，实际上是因为一致地强调访问器和改值器导致的
    > ? 为什么违反了? 感觉是因为ctxt.getOptions()，如果返回的是对象，就违反了对象的原则，从而违反了得墨宓定律。
> 由此产生的一个想法就是： 让数据结构只简单地拥有公共变量，没有函数。而对象则拥有私有变量和公共函数。

> 对象（类）应该隐藏结构。 

5. 数据传送对象
最精简的数据结构，是一个只有公共变量、没有函数的类。这种数据传送对象DTO. 

6. 总结
> 在实际情况中，通常会面对两种需求：一是增加新的类型，二是增加新的行为。面向对象，隐藏数据，便于添加对象，无须改变现有结构。数据结构则便于添加函数，添加变量会引起全局的混乱。
如何平衡呢？在面向对象中的想法就是把数据结构转变为Bean这类特别的类来做，提供公有的访问器和改值器。一般的类最后私有化变量。

## I. 错误处理

错误处理很重要，但是如果它搞乱了代码逻辑，就是错误的做法。
1. 使用异常而非返回码
    > 调用者必须在调用之后即刻检查错误，不幸地是，这个步骤很容易被遗忘
2. 先写try-catch-finally语句
    > try中的代码表明随时都可以取消，catch的代码表示替代方案。 其实这种方案的想法就是面对测试编程，尝试编写强行抛出异常的测试，再往处理器中添加行为，使之满足测试要求。
    > 这也是一种很好的写代码的入口方式
3. 使用不可控异常
    > 这是一种有利有弊的操作；一方面，这会破坏开闭原则，即当最底层的代码进行改变时，比如抛出某个异常，上层都需要为此进行改变，对一般的应用开发，会耗费非常大的成本；另一方面，可控异常可以较快地反映错误
    > C++,C#就没有考虑不可控异常，直接将异常当地处理
4. 给出异常发生的环境说明，异常说明应该详尽，至少包括失败的操作和失败类型
5. 将第三方的API异常进行打包是一件有益于代码整洁和解耦的操作
    - 修改之前
    ```java
    ACMEPort port = new ACEMPort(12);
    try {
        port.open();
    } catch (DeviceResponseException e) {
        reportPortError(e);
        logger.log("Device response execption");
    } catch (ATM1212UnlockedException e) {
        reportPortError(e);
        logger.log("Unlock exception", e);
    } catch (GMXError e) {
        reportPortError(e);
        logger.log("Device response exception");
    } finally {

    }
    ```
    - 修改之后
    ```java
    LocalPort port = new LocalPort(12);
    try {
        port.open();
    } catch (PortDeviceFailure e) {
        reportError(e);
        logger.log(e.getMessage(), e);
    } finally {

    }

    public class LocalPort {
        private ACMEPort innnerPort;
        
        public LocalPort(int portNumber) {
            innnerPort = new ACMEPort(portNumber);
        }

        public void open() {
            try {
                innerPort.open();
            } catch (DeviceResponseException e) {
                throw new PortDeviceFailure(e);
            } catch (ATM1212UnlockedException e) {
                throw new PortDeviceFailure(e);
            } catch (GMXError e) {
                throw new PortDeviceFailure(e);
            }
            ... 
        }
    }
    ```
6. 定义常规流程。当常规逻辑被异常打断时，可以考虑使用特例模式，即创建一个类或者配置一个对象来处理特例。
7. 不要返回null值和传递null值!!!

## J. 边界

使用第三方的代码，第三方程序包和框架提供普适性，往往存在着很大的张力。
作为使用者，一种建议是应该对代码进行一定程度的封装。

习惯
1. 学习性测试：也是自己常有的习惯
    > 学习性测试事一种精确试验，一方面可以增进对API的理解，另一方面可以确保第三方程序包按照我们想要的方式工作。 进一步，还可以学习到相关的新的特性
2. 未来的属性： 考虑Adapter模式，封装为接口
3. 边界的代码需要清晰的分割和定义期望的测试，应该避免我们的代码过多地了解第三方代码中的特定信息。

## K. 单元测试

单元测试非常重要， 测试应该像生产代码一样好好地维护

1. TDD三定律：
    - 在编写不能通过的单元测试前，不可编写生产代码
    - 只可编写刚好无法通过的单元测试，不能编译也算不通过
    - 值编写刚好足以通过当前失败测试的生产代码

2. 测试代码应该和生产代码一样，保持整洁
    > !!! 最重要的，可读性

3. 断言形式总结
    - assertTrue
    - assertFalse
    - assertContains 集合
    - assertEqual

4. 测试的三个过程：
    - 构造 build
    - 操作 operate
    - 测试 check

5. 测试的原则
    - 每个测试保证一个断言，对于重复的代码考虑字符串映射（位标记）、模板方法来消除代重复问题
        > 也并非要一个断言，但是断言一定要保持在特别小的数量
    - 每个测试函数一个概念

6. 测试的原则 FIRST
    - Fast 快速
    - Independent 独立
    - Repeatable 可重复
    - Self-Validating 自足验证
    - Timely 及时

## L. 类

前面主要讨论的是代码语句及由代码语句构成的函数的表达力。

> 注意静态变量和非静态变量的多种叫法；
> 非静态变量又称为实体变量，静态变量又称为类变量

1. 类的组织
    > 对于类来说，从一组变量列表开始，顺序通常是公有静态变量，私有静态变量，私有实体变量，公有实体变量。接着是共有函数的组织，公有函数的组织的建议是按照调用顺序。
    - 封装：通常我们喜欢保持变量和工具函数的私有化，有时我们也需要用到protected变量或工具函数，好让测试可以访问
2. 类应该短小
    - 标准：单一职责原则，类的名称应该能描述其职责，如果都无法为某个类以精确的命名，那么这个类多半是有问题了。
        > 类的模块应该只有一条加以修改的理由。系统应该由许多短小的类而不是少量巨大的类组成。

3. 内聚
    - 内聚即指中的方法和变量相互依赖、相互结合，
        - 方法与变量之间的联系： 类中的变量基本上都被类中的方法覆盖，覆盖得越多，说明内聚性越强。
        - 方法与方法之间的联系： 方法之间相互调用
        - 变量与变量之间的联系：无

4. 如何拆分巨大的函数为小类？
    > 实际上的想法就是首先按函数的每个过程从职责层面进行划分。然后，把某个职责抽象为类，相关涉及到的变量直接提升为类的实体变量。
    - 重构后的程序往往有更长、更有描述性的变量名。函数和类声明可以当作是给代码添加注释的一种手段
    - 这个过程如何做？
        > 一种建议就是面向测试编程，每进行修改一次，就进行测试一次。

5. 为了修改而组织
    - 开闭原则一直是一个非常重要的原则！ 即对扩展开放，对修改封闭
    - 通常的一种想法就是提出抽象类，进行子类化的方法来达到目的。即把与不变的抽为基类，把各种的其它的情况但是需要保持不变的变为子类。当需要增加时，增加子类即可

6. 隔离修改
    - 通常来说，需求会改变，所以代码也会改变。具体类包含实现细节。所以我们的想法就是能够避免客户所用到的接触到具体类的实现，即高层次使用，这样也就能做到隔离修改的目的
    - 一种解决的想法就是借助接口和抽象类来做隔离这些细节带来的影响
    - 测试可以直接面向接口测试
    > 为了降低连接度，类的设计会考虑到遵循另外一条原则，即依赖倒置原则

## M. 系统
> 程序的设计实际上从某种方面都是从生活中进行学习。对于系统架构来说，学习的标准就是建筑行业

复杂要人命，它消磨开发者的生命，让产品难以规划、构建和测试。
除去代码层次上的整洁，系统上的整洁同样重要

1. 如何建造一个城市
    > 其实可以发现，建造一座城市，一个人不能熟知所有的细节，也不能完成所有的工作。每个城市在运转时形成了由一组组人管理不同的部分，彼此互相合作。

2. 将系统的构造和使用分开
    - 系统的构造和使用，也可以说是启动过程和启动之后，也就是编译和运行。 在启动过程中构建应用对象，会存在相互纠结的依赖关系
    - 一个坏的例子
    ```java
    // class
    private Service service;
    public Service getService() {
        if (service == null) {
            service = new MyServiceImpl(...)
        }
        return service;
    }
    ```
    - 问题
        > 这里使用了延迟初始化/赋值的技术，问题就在编译器在解释时，需要把MyServiceImpl的代码全部解析为源代码。而且测试部分想要测试时，必须对该部分进行测试，加大了测试的难度。没有做到测试部分的独立性。实际上我们的期望是运行时构建即可，分别进行测试。
        - 延迟初始化这种技术不好?
    - 如何做？
        - 一种最初步的想法就是将全部构造搬迁到main函数中，负责管理构造过程，而且将其他部分认为都是构建好的
        - 使用工厂方法分离构造过程， 系统的构造和具体工厂的实现细节分开。 何时创建对象
        - 一种更高效的方法： 依赖注入

3. 依赖注入
    - 一种基本的想法就是把控制也看成一种职责，交给特定的类来管理。专业术语：控制翻转
    - 例子： Spring, Java DI容器, XML配置文件其实也是用的这个
    - 相关问题：
        - 系统如何扩容？ 当对系统提出更高层次的要求时，系统如何进行扩展
            - EJB做法
                > EJB采用传统的继承来做，非常不好，一个类中会出现太多的竖向和方法
            - 横贯式关注面 面向方面编程 AOP
                > 也就是对整个架构来讲，利用多个切面的组合来管理系统。 这个方面的划分往往是根据某种共有的特性来划分。
                - AOP如何用代码实现? 
                    > 系统将每个类外面都套了一层，装饰者模式， 客户以为与实际对象打交道，实际上是先跟方面进行打交道。
                    > 方面其实也就是一个系统管理者的身份
                    > Spring 简化了方面编程，使用了描述性语言来做
            - something else: 同AOP一样使用的是字节码技术， 即getattr()
                > 字节码操作库：在运行层面来操作代码，动态（运行过程中）指定类和方法的库。可以由Java或者其他语言写； 代码和复杂度是两大弱点
            - 纯Java AOP框架
    - 相关概念
        - POJO: 普通的javabean
        - EJB: 企业级javabean规范
    - 好处：
        - 测试驱动系统架构
            > 将代码层面与架构关注面分离开，可以用测试来驱动架构。
        - 优化决策： 实现了分散化管理和决策
        - 模块化(尽量使用大概可工作的最简单方案)+关注面： 各部分独立，关注于自我的部分，进一步可以开发该模块领域特定语言

## N. 迭进
> 这章题目有点晦涩，也就是教怎么做到整洁开发？

整洁开发四个重要性由高到低的考虑顺序
- 运行所有的测试
    > 只有可验证才能保证可靠性
- 重构
    - 不可重复：即指类不能重复，同时也可以指方法的实现应该避免重复。模板方法是重用的方法，把非重复的内容交给实际去做。
    - 表达力： 好名称、好类名和好函数名。 只有通过不断尝试才能达到
    - 尽可能少的类和方法
        > 上面的概念不可过度使用；也不可因为教条主义使得类又大又长

## O. 并发编程

对象是过程的抽象，线程是调度的抽象

> 要认识到并发设计是一件超级难的事情

> 私以为，多线程编程其实是想借助并行，即同时运行多个程序来提高效率。但是，者多个线程之间难免会涉及到临界区，临界区往往还会涉及到数量的问题，因此需要对临界区的互斥访问。

1. 为什么要并发？
    - 并发是什么？
        - 并发也是一种解耦策略，它帮助我们把做什么（目的）和何时（时机）做分解开
        - 单线程应用中，目的与时机紧密耦合，只需要根据堆栈跟踪即可断定应用程序的状态
    - 并发的目的
        - 并发主要是解耦，解耦目的和时间主要是为了改变应用程序的吞吐量和结构，响应时间
    - 并发的场景
        - Servlet, 一个页面请求的资源被多个所共享
        - 单线程聚合信息，需要访问多个web网点
        - 考虑某个解释大量数据集，但只在处理完全部数据后给出一个完整解决方案的系统。 数据集并行处理
    - 注意
        - 并发并不总是能改进性能。并发需要系统在多个CPU之间切换以及维护互斥访问的开销。所以相对来说，并发会在性能和编写额外代码上增加一些开销。同时，并发带来的好处只在多个线程或者处理器之间能够分享大量等待时间的时候，可以充分地利用等待时间。
        - 正确的并发是复杂的，对简单的问题同时如此
        - 并发常常需要对设计策略的根本性改变

2. 理解并发的关键
    - Just-In-Time 编译器如何对待生成的字节码?
        > Java字节码是Java虚拟机执行的一种指令格式。感觉上也就是指令吧
    - Java内存模型认为什么东西具有原子性？
        > 区分原子性的东西，即多个线程会同时执行到。

3. 并发防御原则
    - 单一职责原则： 应该分离并发代码和非并发代码
        > 一种可行的方案是在并发代码和非并发代码的边界使用POJO来封装，因此在测试时可以分离测试
    - 限制数据作用域
        > 在Java中唯一的解决方案就是采用synchronized关键字。 限制临界区的数量非常重要
        - 不好的后果
            - 忘记保护一个或多个临界区
            - 花很多时间保证一切受到保护
            - 很难找到错误源，判断错误源
    - 推论：使用数据副本
        - 避免数据共享的好方法就是一开始就避免共享数据。复制对象只可以通过只读方式对待，如果需要修改对象，则从多个线程收集所有复本的结果，并在单线程中进行合并
        - balance: 使用对象复本避免了锁定而省下的价值是否有可能补偿得上额外的创建成本和垃圾收集开销
    - 线程应尽可能独立
    - 了解Java库 Java5
        - 使用类库提供的安全群集
        - 使用executor框架执行无关任务
        - 尽可能使用非锁定解决方案
        - 有几个类是非线程并发的
            > 获取、释放锁， 计数器锁， 指定数量事件发生锁

4. 了解执行模型
    - 基础定义
        - 限制资源，固定尺寸或数量的资源
        - 互斥： 每个时刻仅有一个线程能访问共享资源或共享数据
        - 线程饥饿： 一个或一组线程长时间内或者永久被禁止
        - 死锁：多个线程互相等待执行结束
        - 活锁： 多次尝试起步，却总是失败
    - 执行模型
        - 生产者-消费者模型： 固定数量的共享资源，一方提供，一方使用
        - 读者-写着模型： 共享数据， 读者读取使用， 写者进行数据更新
            > https://blog.csdn.net/yanfeivip8/article/details/12527047
        - 哲学家问题： 竞争式系统。 多个系统同时争夺共有资源
            > https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98
    - 工具： 
        - 信号变量mutex, 专门负责互斥使用
        - 计数变量，对一定数量进行统计
        > 一般地，对于共享资源的访问，以及计数变量的更改都要求使用信号变量; 
    - 设计关键： 对入口和出口的限制进行准确的分析
    - 实战： todo

5. 警惕同步方法之间的依赖
    > 如果多个方法都是同步，并且产生依赖确实是一件头大的事。 建议使用一个共享对象的多个方法
    - 如何使用一个共享对象的多个方法?
        - 基于客户端的锁定： 客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码
        - 基于服务端的锁定，在服务端内创建服务端的方法，调用所有方法，然后解锁，让客户端代码调用新方法
        - 适配服务端： 创建执行锁定的中间层

6. 保持同步区域微小
7. 很难编写正确的关闭代码
    > 编写永久运行和编写运行一段时间后平静地关闭的系统是两码事
    > 在多线程中，平静关闭往往很难做到，常见问题与死锁有关，线程一直等待永远不会到来的信号。
    > 1. 一个系统从父进程中分出多个子进程，当某个子进程发生死锁时
    > 2. 生产者消费者模型中，生产者已经按照父进程要求迅速关闭，然后消费者会一直迟迟地等待着资源不能关闭

8. 测试线程代码
    > 编写最有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果测试失败，跟踪错误。别因为后来测试通过后来的运行就忽略失败
    - 将偶然发生的失败看成线程失败
    - 先使非线程代码可工作
    - 编写可插拔的线程代码： 编写可在数个配置环境下运行的线程代码
        - 单线程与多个线程在执行时不同的情况
        - 线程代码与实物或者测试替身互动
        - 用运行快速、缓慢或有变动的测试替身执行
        - 将测试配置为能运行一定数量的迭代
    - 编写可调整的线程代码： 即线程的数量可调整
    - 运行多于处理器数量的线程
    - 在不同的平台上运行
    - 装置试错代码，试图用随机方法来测试平时无法覆盖的路径。 Object.wait(), sleep(), yield() 和 priority(), 改变代码的执行顺序。
        - 如何装置？
            - 硬编码：手工插入这些语句
            - 自动化： 使用Aspect-Oriented Framework, ASM之类工具通过编程来装置代码。 专门使用单个类来做。

## P. 逐步改进：一个关于Args的实例

1. 准则： 编程如同写作文，不可能一开始就写得非常好，是逐步进行迭代的。 对于程序来说，目标首先一开始是能工作，但是最后一个一定要是一个完美的状态。

2. 可以感觉到的是Args的源码有着非常好的设计，体现在以下几个方面：
    - 将一个大的函数按简洁代码的要求拆分为足够小的函数
    - 每个类的书写都符号规范
    - 代码的设计很好地符合了设计模式的指导，即高内聚、低耦合； 活用继承和接口
    - 异常的处理也非常合理

3. 实际指导意义
    > 首先不可能从最原始的想法开始推，但一般开发来说，不要求很复杂，我们只需要首先开发出第一个可行的版本，然后再秉承着“测试通过，不重复，短小的类”的原则进行更新

## Q. JUnit内幕
## R. 重构SerialDate
## S. 味道与启发
## 附录： 并发编程II


