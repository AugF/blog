---
title: easy offer details
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-18 19:39:11
tags:
- algorithm
- easy-offer
categories:
- [algorithm, easy-offer]
---

总结

1. 找出数组中重复的数字
注意这里的题目给的长度为n的数组，数组所有的数字都在0~n-1范围内
找出重复的元素，一种非常简单的思想就是hash，看hash位置上是否对应元素出现了两次。
而这里给的题明显有针对性，就是探讨能否在原数组上做hash之类的工作，于是想到了可以不断填坑。当遇到了非对应的那个坑但是有重复元素则退出

2. 不修改数组找出重复的数字
注意到这里的题给的也有意思，数组的长度为n+1, 所有的数均在1~n.

这里是二分法非数组索引的应用，对于数值来说，中位数的一边一定存在实际的计数大于所在的坑位

这里二分法就是一个递归的过程

3. 二维数组的查找
分治也可以做，但是比较麻烦

4. 从尾到头打印链表
查看vector一些常用的东西

5. 重建二叉树
层次遍历怎么实现的？

6. 二叉树的下一个节点
循环的再次理解

while(p->left){

}
通常需要对p再进行输出处理，p是有实际含义的值

while(p){

}
通常对p判断是否为空，来查看里面的循环的执行情况；而真正的返回值的情况应该在括号内

理解这两个之间的不同！！！

7. 用两个栈实现队列
队列需要什么功能？
入队，出队，返回top元素，所以这里我们就只需要考虑这些情况就可以了
> 入栈，当要压入元素时直接进行压入；当要处理末尾元素时，考虑怎么处理，后如的再压栈，那么栈顶就是队首元素

8. 旋转数组的最小数字
算法步骤：
- 如果长度不合法，返回不正确的结果
- 如果尾部等于头结点的元素
- 排除掉不存在解的情况 while(n>0 && nums[n]=nums[0]) n--  // 这里为什么是n>0, 很有讲究的！！！
- 使用二分法查找问题的解

9. 矩阵中的路径
是否有某个解

- 首先找到起始元素，即找到某个连通分支图的起点。 可能图中有多个连通分支
- dfs(matrix, str, len, x,y){
    // 使用这个框架，每个点不能往回走
    //
    - 不等， 返回true
    - 达到尺寸，返回false
    - 对可能的情况进行枚举，并且进一步进行求解， 递归每个点
}

10. 机器人的运动范围
机器人能到达多少格子？
BFS, 标志状态位， 对分支的限制函数的加法

11. 剪绳子
数学知识， 分为多个3的做法

12. 二进制1中的做法
注意，统计1的时候负数不可，直接对无符号数进行统计即可
待做：

13. 数值的整数次方
记得负数进行取倒数即可

14. 在O(1)时间删除链表节点
直接进行交换链表的值即可

15. 删除链表重复的节点
双指针算法，而且注意给出虚拟头指针。
i指向上一个的头，j指向下下一个的开始


16. 正则表达式匹配
> 说明一个问题，啥问题？凡是字符串匹配都可以用这种动态规划的思想来思考

s=aa
p=a.*

f[i][j] 所有s[1-i], p[1-j]是否匹配，布尔值
集合划分
f[i][j]
以p为标准
- p[j]='.':f[i][j] = f[i+1][j+1]
- p[j]==s[i] f[i][j] = f[i+1][j+1]
- p[j+1] = * f[i][j] = f[i][j+2]（匹配0个） || f[i+1][j](匹配多个)
> 这里用了递归的思想

f[n][m] = true;

f[0][0]


17. 表示数值的字符串！！！
分情况讨论的顶点


18. 调整数组顺序使奇数位于偶数前面
快排思想的运用，一次划分两个不同性质的集合
二分法，找到两个不同不相交性质的中点

19. 树的子结构
递归理解的经典版本
https://www.acwing.com/problem/content/35/
> 判断一棵树是否是另一棵树的子结构，怎么判断？
如果该点是，返回；否则，对左孩子和右孩子进行判定

20. 二叉树的镜像

21. 对称的二叉树

22. 顺时针打印矩阵
方向的运用

23. 包含min函数的栈
单调栈

24. 栈的压入、弹出序列
模拟

25. 不分行从上往下打印二叉树
> 感觉队列不能存储空节点，而dfs很轻易做到；但是可以标记一下的
 
26. 分行从上往下打印二叉树
nullptr
27. 之字形从上往下打印二叉树
flag=fasle;   flag=!flag;

28. 二叉树搜索树的后序遍历序列
给定一个整数数组，判断该数组是否为某二叉搜索树的后序遍历结果
[1,2,3,43,3,3]
> 同前面给定前序遍历或者中序遍历数组一样，首先是关键要找到一个代表元素，然后找到切分位置
思路:
```C++
ans = dfs(nums, 0, s.size()-1);
bool dfs(nums, l, r){
    if(l>=r) return true;
    int root=nums[r];
    int k=l; // 找到分界点
    while(k<=r && nums[k] < root) k++;
    for(int i=k;i < r;i++)
        if(nums[i] < root) return false;
    return dfs(nums, l, k-1) && dfs(nums, k, r);
}
```

29. 二叉树的和为某一值的路径
dfs判断路径是否符合, 进行值减去即可

30. 复杂链表的复刻
在原链表的基础上每个节点还有一个额外的指针指向链表中随机的节点

31. 二叉搜索树与双向链表
通过二叉搜索树建立一个双向链表

32. 序列化二叉树

33. 数字排列
输入一组数字（可能包含重复数字），输出其具有的所有排列方式

34. 数组中出现次数超过一半的数字
O(n), O(1) 
注意就是代码的复杂度.分情况讨论，当

35. 最小的k个数

36. 数据流中的中位数

37. 连续子数组的最大和

38. 从1到n整数中1出现的次数

39. 数字序列中某一位的数字

40. 把数组排成最小的数

41. 把数字翻译成字符串

42. 礼物的最大价值

43. 最长不含重复字符的子字符串

44. 丑数

45. 字符串中第一个只出现一次的字符

46. 字符流中第一个只出现一次的字符

47. 数组中的逆序对数

48. 两个链表的第一个公共结点

49. 数字在排序数组中出现的次数

50. 0到n-1中缺失的数字

51. 数组中数值和下标相等的元素

52. 二叉搜索树的第k个节点

53. 二叉树的深度

54. 平衡二叉树

55. 数组中只出现一次的数字

56. 和为S的两个数字

57. 和为S的连续正数序列

58. 翻转单词顺序

59. 左旋转字符串

60. 滑动窗口的最大值

61. 骰子的点数

62. 扑克牌的顺子

63. 圆圈中最后剩下的数字

64. 股票的最大利润

65. 计算1+2+..+n

66. 不用加减乘除做加法

67. 构建乘积数组

68. 把字符串转换为整数

69. 树中两个节点的最低公共祖先
## 总结
- 复习栈、队列和

变量重名，大忌！！ 注意检查这个错误
函数参数名一般不要为i,j

c++运算符优先级

大致感觉
1 ::
2 a++ () {} [] . ->
3 ++a ! ~ *a &a sizeof new
4 .* ->*
5 * / %
6 + -
7 << >>
8 <= >=
9 &
9.5 == !=
10 ^
11 |
12 &&
13 ||
14 +=

再思考用栈模拟递归
## 递归的精妙之处

快排
```
void quick_sort(int l,int r) {
    if(l>=r) return; // basic
    int x=a[l],i=l,j=r;
    while(i<j){ // 这里为什么是i<j
        while(a[i]<x) i++;
        while(a[j]<x) j--;
        if(i<j) swap(a[i],a[j]);
    }
    quick_sort(l,i);
    quick_sort(i+1,r);
}

```

归并
```
merge_sort(int l,int r){
    if(base) //base;
    merge_sort(1);
    merge_sort(2);
    combine;
}
```

扩展欧几里得算法
ax+by=d,   
```
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y= 0;
        return a;
    }
    int res = exgcd(b, a%b, y, x);  
    y -= a/b *x; // 合并结果对结果进行改进
    return res;
}

```


递归分治和DFS之间的感觉
分治强调范围的缩小
> 也可以理解为特殊的DFS, 层数是通过区间长度为base来限制。划分技巧定的，导致每次一个点到其他点的方法都是确定，即确定的区间划分策略
> 二叉树的遍历则可以认为物理确定了划分策略就为左右子树
> 递归则可以看作划分的不均匀，也就是单位1和剩余，不过降低了规模而已。比如，路径缩短一点。
> 动态规划是一种本身就有拓扑路径的结构

> 循环也是一种递归，条件写在最前面，前后更新等等都有很多种讲究
DFS则是层数限制，每层展开是每个点的可行路径


BFS-队列

递归-栈
> 栈不断压入当前根节点等内容，直到最基本的情况，然后用解决最基本的情况，不断倒着解决，直到解决原本的问题，基本问题有解。需要回溯计算压存的解的计算公式，有特殊的返回值

DFS-栈
> DFS感觉有点不一样的就是，每层的东西都可以算，一定不断得到结果，到最后一层于是就得到了最终结果；然后，如果没有，则回溯再找解。 DFS到达根节点的感觉就是无返回值返回的感觉

两者相同的点最终都是返回原问题的解

中序遍历 左,中，右-栈
> 是递归的感觉，相当于不是一次压栈结束的，到达了底层的一个节点又需要返回，然后再压数据，再找一次底层；这里底层的标志就是是否为空

二叉树的中序遍历等多种遍历方式的刷题


所谓循环：base, k, dfs()


调试代码的几种方法：
1. printf大法，输出所有东西

2. 没有东西的时候，注释代码，或者删代码法，知道没有错误为止

RunTime Exlimit: 其他语言有注释的，即有堆栈显示哪里出现了错误，所以可以得到直接更改


注意，DFS中节点有特别重要有意思的一点就是节点的状态是可以进行用二进制数来表示，进行优化的
