---
title: algorithm acwing search graph
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 12:17:32
tags:
- algorithm
- acwing
- search
- graph
categories:
- [algorithm, acwing, basic, search_graph]
---
# 1. BFS/DFS
## 1. DFS
stack O(h) 不具有最短性
    回溯，剪枝
    思路比较奇怪的都有DFS来做
    俗称暴力搜索！
    关键：使用什么顺序来进行搜索
    > 一个很执着的人！，回溯法，出去，回来务必注意需要恢复现场
    有些题会判断最优，有些题不需要
```
#include<iostream>
using namespace std;
const int N=10;
int n;
int path[N];
bool st[N];

void dfs(int u){ // 这里与path对应
    if(u==n){
        for(int i=0;i<n;i++) printf("%d ",path[i]);
        puts("");
        return;
    }
    for(int i=1;i<=n;i++){ // 这里与st对应
        if(!st[i]){
            path[u]=i;
            st[i]=true;
            dfs(u+1);
            st[i]=false;
        }
    }
}
int main(){
    cin>>n;
    dfs(0);
    return 0;
}

```
八皇后法：依旧使用框架
n*n! 2^(n^2)

DP是无环的最短路问题
深搜可以保证一次搜索到终点，但是不能保证搜索到的路径是最短的
深度搜索可能随机搜索到一条路

### 1.1 统一考虑的格式
数据范围 N
最优解： 需要输出的东西
约束条件

### 1.1 全排列问题
DFS, 全排列问题
顺序！！  _, _, _, _
要以什么样的顺序来遍历所有的方案，这里很简单地就是每一位到底选什么的方案
DFS就是递归
> 当初始状态不属于什么具体的含义的时候，往往恢复现场写在，展开每个子树那里

N=20
最优解： path[N]
约束条件: st[N]

### 1.2 n皇后问题
N=20
最优解： g[N][N] 棋盘
约束条件: col[N], dg[N*2] udg[N*2]


## BFS
queue O(2^h) 最短性，当所有边的权都为0,1时是。 

迷宫问题： 保证了一定存在路
技巧就在于少写循环判断语句

如何输出路径？就是在该输出的位置增加链表


八数码问题： BFS求最短路
把每个方格看作个体，当前棋盘的所有的方格组合而成为整个棋盘的状态，然后每个状态之间有路可走，研究的点就是如何进行搜索，使得能够从一个状态到达另一个状态，并且进行搜索！

所以问题的关键：
1. 状态表示复杂
2. 如何记录两个状态之间的距离

求最短路

最短路简单的做法：
q[N],d[N]

> d[N]是什么，d[N]是BFS中用于搜索，用来更新距离计算公式的

那么需要考虑
- 如何存储
- 如何定义最短距离
距离数组的小标如何表示
queue<string>
dict: 字典，哈希表unordered_map<string,int>

queue<string>
如何从一个字符串到达另一个字符串？
移动，恢复
# 2. 树和图
## 2.1 存储方式
邻接矩阵: 稠密图
邻接表：拉链法，存储每个点可以走到哪个点
> 可以用vector来做，但是就效率而言没有数组模拟的快， 稀疏图

## 2.2 遍历方式
O(n+m)
 
注意最大值最小
最小值最大两者的区别
 
> 在图里，进行遍历，如果有环，怎么进行统计数？？？，想想真是一个问题！！！
> 在图中，因为有n个顶点，所以对于n个顶点，每两个边之间最多只可能有两种情况，所以根据握手定理，出度与入度之和就为顶点数的二倍

深度优先和宽度优先

如何将一维扩展到二维，以及多维，实际上就是在多维空间中寻找一种顺序，使得这种顺序可以通过一维的方式来进行模拟

BFS:
h[N],e[M],ne[M],idx;
d[N],q[N];  // d[N]==-1,表示是否进行了遍历

应用：有向图的拓扑序列。 拓扑序列的两种求的方法
拓扑排序的算法流程
```
queue<- 所有入度为0的点
while(queue不空)
    t<-队头
    枚举t的所有出边t->j:
        删除t->j, d[j]--;
        if(d[j]==0) queue<-j;
```

DFS:
h[N],e[M],ne[M],idx
st[N]

搜索的扩展：人工智能技术的树


# 3. 最短路问题
1. 单源最短路
- 所有边权都是正数
    - 朴素Dijkstra O(n^2) 稠密
    ```
    for v: 1-n:
        t<- 不在S中的距离最近的点 n-i  st[i]:n
        s<-t, 共n次
        用t来更新其他顶点 t->v， 共m次
    ```
    - 堆优化版Dijstra O(mlogn) 稀疏
    > 看哪些地方可以优化
    > 手写堆，可以保证n个元素
    > pq, 不支持修改元素， m个元素
- 存在负权边
    - Bellman-ford O(nm)
    ```
    struct{
        int a,b,w;
    } edge[M];
    ```
    > (a, b): w
    > dist[b] = min(dist[b], dist[a] + w); 松弛操作
    > 对所有的边都满足 dist[b]<= dist[a]+w 三角不等式

    > 如果有负权回路不一定存在。n+1 条边，存在负环
    > O(nm)
    > 特解的题：最多k条边的题
    > 当存在负环时，不存在最短路径。如果负环为自环则无所谓
    > 因为更新会发生串联，所以需要备份，backup[N]. <1,2>:1, <2,3>:1,  <1.3>: 3
    > 只要有负环存在，可以不断更新负环中的数值，最终到达负无穷
    - SPFA 一般：O(m) 最坏：O(nm)
    > bellman_ford 不一定
    > 这里利用了宽搜， BFS, 只有前面的点变小了，后面的点才有可能变小
    > 网格特别容易卡spfa

    > > 应用： 1. 最短路  2. 判断负权回路（指回路的总长度为负数）
    > > 在2时，因为2本身一个环里的权会不断减小，所以没有必要赋初值
2. 多源最短路- Floyd O(n^3)
> 基于动态规划，三维
> d[k,i,j]: 只经过k节点，从i到达j的路径
> d[k,i,j] = min{d[k-1,i,j], d[k-1,i,k]+d[k-1,k,j]}
https://www.cnblogs.com/chenying99/p/3932877.html

稠密图：m~n^2
稀疏图：m~n 
> 考虑无重边和自环的话，那么最多的边则就是完全图，即n^2;
> 考查的点不会是正确性，从背景中抽象为最短路问题

> 无向图是一种特殊的有向图


# 4. 最小生成树
Prim算法
- 朴素版 稠密图 O(n^2)


Kruskal算法
O(mlogm) 稀疏图
1. 对边进行排序O(mlogm)
2. 从小到大选取边，若该边与生成树形成环则不加入，否则加入； 直到加入了n-1条边即结束
> 和bellman-ford一样只需要用结构体存储边即可

> 选择，稠密图用Prim算法；稀疏图用Kruskal算法

# 5. 二分图
- 染色法 O(n+m)
> 对图中的点染色，深度和宽度优先均可。
> 如果一个点出现两个颜色，则说明该图不是二分图

- 匈牙利算法 O(nm)
> 实际运行时间一般远小于O(nm)
> 只会找左边所有点所对应的边
> st[N], 存储当前使用匹配时是否用到该点；在寻找下一轮时，需要更新为0


复杂图论的题
> 二分图： 棋盘覆盖
## Error
Seg F: 
纯随机，然后利用minmax来求解
> 当输入输出规模到达100万时一般才开始考虑用scanf(),而不用cin

检查：

初始化，代码逻辑，赋值等是否出错。
最需要注意的一件事就是尽量用空格来划分代码的逻辑

有问题怎么办？首先确信一部分代码一定是对的，不要怀疑

函数中的变量务必注意要初始化，否则是会出错的！！！



前面的题难点在思路上
图论难点在代码实现上

为之半个小时的调试，发现是一个变量给写错了，唉，就在for循环那里