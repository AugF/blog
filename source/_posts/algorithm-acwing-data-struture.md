---
title: algorithm acwing data-struture
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 12:09:15
tags:
- algorithm
- acwing
categories:
- [algorithm, acwing, basic, data-struture]
---
数据结构

# 1. 链表与邻接表
strut Node{
    int val;
    Node *next;
}; //不讲！

new Node();  // 动态在堆中申请非常慢！
> 可以在初始化时弄多个。

> 数组模拟单链表

- 单链表： 邻接表（存储图和树）
e[N], ne[N]下标,head, idx
> 有个问题，删除后空闲节点不好回收；一般来说不需要管删除的点，浪费即浪费，只是想快，不用考虑内存泄露的方法。
> 写工程时，才需要考虑多久
> 单链表只能向后看，向前只能从头遍历。 O(1)时间插入，O(n)时间; 尾插法O(1), 记录一下即可
注意从0开始存储内容，所以remove和add都是k-1，还要特别注意remove head;

- 双链表： 优化某些问题
e[N],l[N],r[N],0表示头，1表示尾
init: r[0]=1,l[1]=0, idx=2;
注意不需要连起来
务必注意，从2开始存储元素，所以remove和add都需要映射为k-1+2=k+1

struct Node{
    int e,l,r;
}nodes[N];
remove
`nodes[nodes[k].l].r=nodes[k].r`
> 不推荐
# 2. 栈与队列
栈： tt,0
队列：hh,tt
> 边界看个人习惯，0或-1

# 3. 单调栈
> 给定一个序列，求一个数左离它最近小于它的数
暴力做法费时
> 善于发现数据的性质
时间复杂度：每个元素进站一次和最多出站一次，所以算法复杂度为O(n);

# 4. 单调队列
> 求滑动窗口中的最大值和最小值， 凡是能抽象出来。
一个严格单调队列的最小值就是其头和尾。
> 队列的大小不会超过滑动窗口的大小！！！

> 单调栈和单调队列的做法都是通过暴力分析，然后用栈和队列来模拟，并且去掉没有用的元素。然后再剩余的元素有没有单调性，有的话就可以考虑栈和队列。
> 栈是最近最小，队列是全局最小。然后因为单调还可以用二分法来进行查找。

多重背包也可以用滑动窗口来优化，因为滑动窗口可以做

对队列的研究，什么时候入队，什么时候出队？

！！！这里队列里居然存的是下标，天啦一下子就避免了情况的讨论。
> 存下标会很容易来判断什么时候进行元素弹出

> 在实际做的时候，会开O_2和O_3优化，此时速度就与stl相差没多少了
> 但是在做算法题时，拿数组模拟的队列和栈比stl快。 比赛方是不会开优化的！

```
#include<iostream>
using namespace std;
const int N=1e6+10;

int q[N];
int a[N];

int main(){
    int n,k;
    scanf("%d %d",&n,&k);
    for(int i=0; i<n;i++) scanf("%d",&a[i]);
    int hh=0,tt=-1;
    for(int i=0;i<n;i++){
        // 判断对头是否划出了窗口
        if(hh<=tt && i-k+1 > q[hh]) hh++;
        while(hh<=tt && a[q[tt]]>=a[i]) tt--; //
        printf("hh: %d, tt: %d\n",hh,tt);
        
        q[++tt]=i; // 注意这里模拟的不是实际的物理位置. !!因为hh>tt,当前元素没找出来，注意
        if(i>=k-1) printf("---%d \n",a[q[hh]]);
        
        for(int j=hh;j<=tt;j++) printf("%d ",a[q[j]]);
        puts("");
    }
    return 0;
}
```

# 5. KMP
> S字符串,P模板串
> 从1开始

暴力
```
i:1..n
j:2..m
```

优化：一直向取的距离足够大
> 最少移动距离，最大后缀

next[i]=j: 以i为终点的，所能匹配的最长距离. 关键！一定要理解透，这里比如next[1]=0,表示第一个节点没有匹配的内容。
> 务必注意是当前！
p[1,j]=p[i-j+1,i]

i,j为S和P的指针。
所以在i失配的话。
> 模板串移动的是最长的，所以从模板串的角度来看是最优的！

> 算法时间复杂度是O(n)的，再快不可能有更快的了！

> j最多加m次，j大于0， while循环最多减m次。所以时间复杂度为2m。

注意比较的对象：s[M],p[N]
# 6. Trie树
高效存储和查找字符串及其次数的数据结构
将字符串拆分为各个字母，组合成一个多叉树。
> 相比于kmp，利用了前缀
> 如：abcdef, root->a->b->c->d->e->f->$
> 对于串树，一般只包含大写或小写字母！一定有限制

son[N][26],cnt[N],idx
理解：trie树内部每个节点占用一个idx, idx的取值范围为0-N
son[idx][1]指向关联的下个节点，cnt[idx]以此idx为结尾的单词的个数。

所以不可能有son[1][2]和son[1][3],不对有的，这里是指针

# 7. 并查集
- 将两个集合合并
- 询问两个元素是否在一个集合中
BF: belong[x], 判断两个元素是否在一个集合belong[x]==belong[y];合并需要将一个集合中的所有元素改为另一个
并查集在近乎O(1)的时间内快速支持两个操作。

> 原理：用树来做，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点
> 问题1. 如何判断树根，if(p[x]==x): 特殊情况的处理
> 问题2. 如何求x的集合编号：while(p[x]!=x) x=p[x]; 时间复杂度
> 问题3，如何合并两个集合： p[x]是x的集合，p[y]是y的集合，则p[x]=y;

路径压缩优化：当找到根节点时，把路径上的所有节点都指向根节点. O(1)
> 这里也可以应用一个简单的启发式策略——按秩合并。该方法使用秩来表示树高度的上界，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。为了保存秩，需要额外使用一个与 uset 同长度的数组，并将所有元素都初始化为 0。这样找祖先会减少递归迭代的次数，最坏只有logN次。 暂时这里不采用！

代码核心最关键的就是find()函数！！！

> 集合合并的所有问题都可以用
> 看题目中哪些操作可以优化，考虑什么时候用什么数据结构；操作有什么特点，最小值，堆。
> 区间和啊， 区间数组，树状数组，线段树！！
> 有序链表，平衡树，set来做

# 8. 堆
如何手写一个堆？stl
- 插入一个数
- 求集合中的最小值
- 删除最小值

扩展
- 删除任意一个元素
- 修改任意一个元素

> stl中的堆就是优先队列！！priorityqueue
小根堆
从1开始编号，2i表示左孩子节点，2i+1表示右孩子节点
基本操作
down(x){} // 往下移，跟孩子中最小的进行交换。说明最上面的数变大了所以要往下沉，那么是否无法交换了就说明没有必要往下移动了。
up(x){} // 往上移，只需要与根节点进行比较

变小往上走，变大往下走

数据结构
heap,size

- 插入一个数： heap[++size]=x,up(size)
- 求最小值： heap[1]
- 删除最后一个元素: heap[1]=heap[size], size--,down(1);
- 删除任意一个元素： heap[k]=heap[size], down(k),up(k)(只执行一个);
- 修改任意一个元素: heap[k]=x,down(k),up(k)
完全二叉树。

> 堆排序，把数列建成一个堆，每次把堆顶元素输出

- 如何建堆？
> 一个一个将数进行插入 nlogn.
> O(n), 从n/2开始down到1. n/4+ 2*n/8+3*n/16 +...=O(n)
> 从下往上down可以保证每个儿子都是好的


模拟堆， 删除第k个插入的点
> ph[j]=k  第j个插入的点在堆中对应第k个元素
> hp[k]=j  堆中第k个元素对应第j个插入的点
需要存储映射


# 9. 哈希表
## 9.1 简介
- 存储结构
    开放寻址法、拉链法
- 字符串哈希方式

> N: 1e5 ,1e6
> 把值域大的数映射到值域比较小的数
> 1. 哈希函数，模的数为质数，距离2的整数幂远，数学证明了冲突概率是最小的
> 2. 冲突
cstring: memset

> 感觉上

> 注意，哈希表能使实际求的时候时间复杂度变低，但是并不意味着空间大小会变小

### 9.2 方法
#### 9.2.1 开放寻址法（厕所找坑位法）
查找、删除、添加
如果都满了的话find会陷入死循环，但是经验上来说会用2,-3倍的空间大小。
INT_MAX=0x3f3f3f3f;
memset()按字节，不能处理vector， strcopy()遇到`\0`就结束。
> 哈希表时间复杂度都是O(1)， 用到哈希表O(n).
> 不需要sort一遍，如果sort就会从O(n)->O(nlogn)，变慢

> 对比前面的离散化的思想，不过离散化区间和那道题实际上运用了前缀和来做。
#### 9.2.3 字符串哈希方式
对比与KMP，用于查找模板串是否存在，不一定要用KMP算法。

字符串前缀哈希
h[1]="A"
h[2]="ABC"
> h[n]: 表示前n个字符串的哈希值； h[0]=0;

##### 问题：
1. 如何定义某个前缀的哈希值？把字符串转化为数字！
把字符串看作是P进制的数（Godel编码）
如"ABCD", 注意需要保证唯一性！！！
对应十进制的数：1*p^3 + 2*p^2 + 3*p^1 + 4*p^0
2. 这个数会很大，进行取模, 这里Q会远小于数值: mod Q

结果将任何一个字符串映射为了0 ~ Q-1.

注意！
不能把某一位的字母映射为0, 需要映射为从1开始的数。
假定人品足够好，不考虑冲突；经验值是p取131或13331, Q取2^64,unsigned long long, 所以就不需要取模了，任意一个数都会自动溢出，在绝大概率保证不会出现冲突。

好处：
可以求出字符串所有子串的哈希值：所以就可以用来作字符串的查找
字符串：[l,r]的哈希值h[r]-h[l-1]*p[r-l+1]
> 把所有的看成数位，所以每个数段都有其哈希值。那么，因为最高位当做零位就意味着位数一定？？不需要！！！
因此就可以在线性时间内求出每一段的哈希值。

讨论预处理， h(i)=h(i-1)+str(i);
> 因为这里h()相当于取Q的模，所以h就是没有操作
##### 想想
这里就是超级牛逼的，比KMP还厉害很多！
问某两端是否完全相同

这里感觉上利用了前缀和的思想以及其他，将字符串通过Godel编码（数的进制的方式），映射为数。
因为每一个前缀都是唯一的，所以必然就前缀唯一
？？ 那怎么知道这多个前缀是否是某一特定的字符串的呢？还有怎么插入数据的？

等下这里完全就没有了哈希的概念！！，它是制定了规则。不是前缀树，需要插入一系列字符串进行查找某个字符串是否存在。
就是根据规则，进行计算数就行了，就比较某个区间的计算出来的结果是否相同

但是，预处理的话，一位是对应着多种结果啊，这些是要事先计算出来吗？

##### 作用
快速比较两个字符串是否相等。
O(n), O(1)

可解的题：
搜索哈希，直接搜
兔子
回文串
后缀数组
二维哈希

KMP可以用来求循环节。

# 10. STL初步
vector, string ,queue, priority_queue, stack, dequeue,
set,map,multiset,multimap
unordered_set, ....  // c++中实现的哈希表？？？？
bitset 状态压缩

vector 变长数组，倍增思想。
string   substr(), c_str()//对应char数组指针
queue 队列 push， front, pop
priorityqueue, 堆，优先队列，push, top(),pop()
stack, push, top, pop()
dequeue双端队列, 支持随机访问；
set,map, 基于平衡树（红黑树）来实现的，动态维护有序序列
unordered,  基于哈希表来实现的 
> 需要添加对应的头文件

bitset,  压位
List

set: find() O(n) C++ vector基本用法

## vector
vector<int> a(10,n);
size() // O(1)
empty() //返回
clear() 特有
系统为某一个进程分配空间时，所需时间与空间大小无关，与申请次数有关。
所以1000和1000次1不一样
倍增的思想

申请一个数组长度n=10^6, 一共要申请logN次，额外copy次数平均为1
front() back()
push_back() pop_back()
begin() end()
[]
a.end()=a[size]
迭代器可以看成是指针
a<b, 支持比较运算，基于字典序

## pair
pair<int,int> p;
p.first(), p.second();
支持比较预算，按字典序，以first为第一关键字，second为第二关键字
p=make_pair(10,"yxc")
C++11: p={20,"abd"}
> 某个东西有两种属性
> 三种不同的属性pair<int, pair<int,int>>

> pair vs struct, 比一般的结构体
> string可以用作栈
## string
size() length()
empty(), clear()
a+="def", a+='c';
a.substr(0,2) 起始地址，长度
a.c_str()

## queue
size(), empty(), 没有clear()函数q=queue<int>();
push(), front(), back(), pop()

## priority_queue默认大根堆
push() 插入一个元素
top() 返回堆顶元素
pop() 弹出堆顶元素
无clear元素

如何使用小根堆？ 插入时使用负数
priority_queue<int,vector<int>,greater<int>> heap; // 定义小根堆

## 栈
push, top,pop,size, empty

## deque
效率非常低
size(), empty(), clear()
front()/back()
push_back()/pop_back()
push_front()/pop_front()
begin()/end()
[]
## set/multiset,map/multimap
size()
empty()
clear() O(1)
set/multiset O(logN)
    insert() 插入一个数
    find() 查找一个数
    count() 返回某一个数的个数
    begin()/end()   ++, --返回前驱和后继 O(logN)
    erase()
        (1) 输入是一个数，删除所有x, O(k+logn)
        (2) 输入是一个迭代器, 删除这个迭代器
    lower_bound()/upper_bound() !!!!
        lower_bound() 返回大于等于x的最小的数的迭代器
        upper_bound() 返回大于x的最小的数的迭代器，不存在返回end()
map/multimap
    insert() 插入的是一个pair
    erase() 输入的参数是pair或迭代器
    find()
    [] 时间复杂度是O(logN)??
    > map<string,int> a; a["yxc"]=1
    lower_bound(), upper_bound()
    > 支持排序

unordered_set,unordered_map,unordered_multiset, unordered_multimap
    和上面类似，增删改查的时间复杂度均为O(1)
    但是不支持lower_bound()/upper_bound(), 迭代器的++,--
    > 凡是排序的都不支持

bitset()
    > 1024 bool, 1024B=1KB;  用字节来存 1024/8=128
    > 什么时候用？ 比如10000*10000 bool,  10^8 B, 100MB, 空间限制是64MB
    biset<10000> s; //这里10000指的是个数
    ~s取反， &, |, ^
    >>, <<
    ==, !=
    [] 某位
    count() 返回有多少个1
    any/none()
        any()判断至少有一个1
        none()判断是否全为0
    set() 把所有位置为1
    set(k,v) 将第k位变为v
    reset() 把所有为变为0
    flip() 把所有位取反
    flip(k) 把第k位取反

## 注意
scanf读char时有空格和回车不能处理，读字符串可以进行过滤

比较序列中两个元素的某个关系的最值，如果该关系是双方等价的，那么可以不用存储该元素的数组
先插入再查询可以避免处理空，只是多一个时间复杂度

每次做题前把思路想清楚！！

思考回溯法，在循环前加入语句和循环后加入语句的区别有什么呢

模运算很有意思！！

路径的距离来做

if (a && b), 注意是b不等于0时为真

segment flase: N常数空间开辟不对，或者循环溢出等等
## 课后题
### 最大异或数

> 发现这里的思路跟我自己想的还是有很大差别，比如说我的想法就是直接分析题。怎么得到一组数中所有的最大的异或数。
> 这里的做法就是O(n^3)->O(n^2)
> 记住一定要从暴力解开始出发
```
Trie树来做
int res=0;

// a1,a5;a5,a1; 规定小于数
for(int i=0;i<n;i++){ // 枚举第一个数
    for(int j=0;j<r;j++){  // 试图找最大的数
        max=res(max,ai^aj);
    } // 枚举第二个数
}

首先考虑如何寻找最大的异或数。 
首先找第30位是0的数
倒序找数
```
注意这里M的取值是看实际情况中Trie树中最多有多少个节点，所以要看多种情况来做。
每个叶节点代表一个集合，表示所有能往下走的数。

> 与一开始想法不同的点是，倒序排序的，把所有树给撑满，自己的想法这点出问题了
> 举例子

```
res= res*2+u;
res +=1<<i;

res=1101 -> 11011  二进制乘法的感觉
```

### 食物链
> 首先应该分析题，发现题中种类关系是如此少，以至于所有关系放在一个类中即可

> 哇，居然从路的路径长度入手来看，nb。
> 由距离进行定义，使用模的关系！！厉害，看每个人和领袖之间的距离关系
所以说，构造的时候实际上使用的增加最小长度的路径

> 三类，吃、被吃、同类

算法
> 初始化，每个节点都是根节点，所以初始化为0