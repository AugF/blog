---
title: design pattern details
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-18 18:49:38
tags:
- java
- design_patterns
- details
categories:
- [java, design_patterns, details]
---

参考书籍： head first 之设计模式

相关实现代码： https://github.com/AugF/DesignPatterns

## 1. 设计模式入门

知道封装、抽象、继承、多态这些概念，并不会马上让你变成好的面向对象设计者。设计大师关心的是建立弹性的设计，可以维护，可以应付改变

面向对象，鸭子对象。只要认为实现了鸭子对应的方法就是鸭子

首先，实现基类鸭子会叫，其他鸭子都是基于基类的继承
某天出现了会飞的鸭子，怎么办？在基类中添加飞的接口，？但是，并非所有鸭子都会飞
1. 使用继承，？代码量太大
2. 使用飞和叫两个接口，每个鸭子基于接口的实现，？没有鸭子都需要进行重写内容，无法做到代码复用

设计原则
- 找出应用中可能需要变化之处与其他稳定的代码相分离
- 针对接口编程，而不是针对实现编程

> 与原本不一样的是，这里的想法是针对接口编程，实际上就是针对超类型编程。即将需要变化的用户的行为进行两步抽象，第一步首先为接口，第二步为具体的各种实现，然后具体的类使用的是具体的实现。这里针对接口编程其实也可以看作是抽象类型编程。

<font color='red'>多态！将子类型的实现绑定到父类型上，然后直接用父类型接口的所有方法来做事</font>
有种感觉即是把鸭子的行为委托给了别人。
接口是局部版的抽象，又跟抽象不一样，很奇妙！！
```?
interface FlyBehavior{}

FlyWithWings{  fly(){// action}  }
FlyNoWay{ fly(){//no way}  }

interface QuackBehavior{}

Duck implements FlyWithWings { //？   extends FlyWithWings   错误

}

public class Duck {
    QuackBehavior quackBehavior; // 每只鸭子在构造函数中都会进行实现接口

    public void performQuack(){ 
        quackBehavior.quack();
    }
}

public class MallardDuck extends Duck {
    public MallardDuck() {
        quickBehavior = new Quack(); // 指定接口的行为
    }
}
```

? 先做系统还是然后再分离和封装
需要进行自己预估
? 如果飞行的行为不止对应的方法，还对应着变量， 怎么处理？
> ? 考虑使用方法来管理对象
? Duck不应该设计为接口吗
> 不，需要变化的地方已经做到；继承最大的好处是可以共用共有的东西，所以直接将Duck实例为一个对象即可。

就目前来说，在构造函数中其实还是面对的具体编程，即指定了某个特定的行为。那么如果在运行时使用多台的行为，使得在行为时可以动态改变呢？ 
setattr() 方法

?? 一个很妙的思路，现在虽然将我们所关心的接口分离了，但是的话，还是单个只能表示单个。
如何是一个目标是可以动态改变的呢？
一种想法是设置一个傀儡类，也可以称为模板类，先在构造函数中指定默认的接口实现。并且对外界提供修改该属性值的方法，从而获得修改行为的方式。
> 这里是通过将行为另类地表示为属性，从而根据属性的动态挂定从而获得好的结果

所以需要在运行时改变鸭子的行为，只需要调用鸭子的setter方法即可

### 关系

- Is-A
- Has-A
- implements

> 这里，前面的想法其实所有的一切都是将是一个变为了有一个，其实关键原因在于代码中本身有多个可以变化的东西。如果是是一个的话很难改变，所以我们通常期望的就是是有一个。

于是，得到第三个设计原则
多用组合，少用继承。

> 以上即为策略模式！！！
简单来说，主体的类有多个作为属性的接口，这些接口可以各自进行实现。然后各种各样的人物可以通过继承来实现。

运用
> 对于动作冒险游戏中，各个游戏角色可以使用任意的武器，做任意的动作。

共享词汇的好处，可以高效

### 总结

1. OO基础
    - 抽象
    - 封装
    - 多态
    - 继承
2. OO原则
    - 封装变化
    - 多用组合，少用继承
    - 针对接口编程，不针对实现编程
3. OO特性
    - 可复用
    - 可扩充
    - 可维护

## 2. 观察者模式

让你的对象知悉现状，不会错过该对象感兴趣的事情。对象设置在运行时可决定是否要继续被通知。观察者模式是JDK中运用最多的模式。 松耦合，一对多的关系。

问题：如何实时地显示和更新气象站得到的湿度、温度、气压等信息

一种想法就是设置一个measurementsChanged()方法，当监控到元数据更改时，就进行整体更新数据。

### 2.1 简介

出版者和订阅者=观察者模式
> 即主体对象是出版者，当出版者进行更新时，直接通知订阅者即可；而不是每个订阅者进行实时监听所有的情况。
> ？ 将订阅者列表作为类的属性，然后可以通过set和get进行添加和删除。然后，根据订阅者列表所关注的信息，如果关注的信息发生改变，那么就进行通知。  关注的信息是什么？

>>进一步回答，这里注意到观察者是主动进行添加订阅者的。这里有两个点：

1. 为什么要将订阅者的三个行为作为抽象？ 两个接口之间的关系，实际上因为发布者会管理订阅者的状态，所以使用了订阅者作为函数参数。  抽象为接口是为了方便有更多的订阅者状态管理和订阅者更多的显示功能以及用其他的表示的不合适
2. 关注的信息是如何做到的？ 这里其实就是首先具体实现的主题中会封装一个通知所有订阅者的方法，然后一般来说观测的内容是作为类的属性的。当使用某种方法进行类的属性更改时，记得调用通知所有订阅者的方法即可实现当方法改变时通知了所有的订阅者
3. 实际上订阅者是仅仅与发布者相关的，所以订阅者必须知道发布者的消息，所以一般来说订阅者会将发布者作为类的属性，然后调用它来订阅自己，依此这样就可以完成订阅。
    > 等于说订阅者有发布者的指针

再思考java中的接口设计
> 接口可以封装一些共同的方法

这里的想法是，观察者作为接口, 状态改变时进行更新; 然后接口主题对应于多个观察者，具体的主题是基于接口的实现；可以get,set观察者。 notifyObserves()专注于查看状态改变时更新所有的观察者。
> ? 主题应该才是主题
> ? 怎么实现多个的。

主题只知道观察者实现了某个接口？

!!! 主题唯一的依赖是一个实现了Observe接口的对象列表，可以进行随时增加观察者

<font color='red'>为了交互对象之间的松耦合设计而努力</font>

理解为什么起作用，因为register注册后是将观测者加入到了订阅列表中的，而且当消息更新时，消息更新时是遍历每个观测者并且调用了各自的更新函数的。


其实这种方法与另一种是对立的，即从某种意义上来说为什么不直接发布者提供getter方法呢，每个订阅者直接获取需要的数据。
这样是有问题的，破坏了发布者本身数据的隐私性。
但是，会导致发布者给订阅者需要传送一大波状态。

### 2.2 Java内置的观察者模式
> 观察者模式的运用范围还是超级广的

观察者如何接收通知？？ arg应该只是通知参数
> 一个特别有意思的东西就是实现了Changed参数，即可以从某种范围来进行约束。如果手动应该怎么设计

java.util.Oberverable是一个类是有问题的，使用

// 注意接口和类的区别，接口没有成员变量，所有方法必须是抽象方法，支持多继承。抽象类可以有方法实现，只要有一个抽象类即认为为抽象类

在界面设计中最为频繁。
当设计出一个新的部件时，通常会问是否增加对应的亲听着，以及对应的倾听者发出什么样的行为。
每个倾听者倾听的是不同的行为，然后把所有的事件也进行了一定程度的封装。

大量运用GUI框架中

## 3. 装饰者模式
使用对象组合的方式，在运行时装饰类
讲对象包装起来，赋予新的组合

问题引入：在星巴克咖啡中，如何实现多种种类的咖啡的支付？

1. 直接针对每种实现：组合爆炸
2. 针对原料进行继承实现，当原材料发生变化时会出现问题

<font color='red'>类应该对扩展开放，对修改关闭</font>

初步印象：
有一个对象，然后可以有各种对象可以按任何顺序来装饰它，然后最后的总能记住前面的顺序是如何达到的，从而可以准确地计算出对应对象的价格

分析：
1. 被装饰者和装饰者一直始终拥有相同的超类型
2. 可以用一个或者多个，装饰器可以替代原本，庄思琪可以在所委托的前后加上自己的行为？？？所以前面那么艰巨的任务是通过这样来实现的？
3. 对象可以在任何时候装饰


尽量不改变原本的设计，所以原本是抽象类也可，当然如果是接口也可。
总共设计到这几方面：
1. 抽象订单 Basic
2. 基本原料， 由Basic继承而来，无参数
3. 可添加接口， 继承自Basic，为什么这样做是为了保持前后加持的行为的统一，又称为装饰器；使用的是继承，所以可以来自于其他装饰器之间的组合关系
4. 可添加原料实现，默认参数为Basic类型，因此可以动态地无穷无尽地进行添加
> 因为一定包含参数，所以这里利用的不是父类的属性，而是基于其他对于父类的基本实现，是一种很牛逼的做法，很厉害了

这就是装饰者模式牛逼的地方所在，不用继承；而使用了一个继承的性质，做到了多种进行叠加的继承的效果，牛逼！！

### 应用范围
当针对特定种类的具体组件是这样的设计将不再有效果。
装饰器方法适用于组件会发生动态变化的情况
装饰器增加行为到被包装对象上。
> 如何窥探装饰链上的每一个装饰者，getDescription()的返回值为ArrayList()类型即可

会带来大量的小类!!!
### 实际应用

Java IO
使用对流的管理，从而来组合各种输入流装饰者来符合用途

### 缺点
1. 很难轻易理解
2. 类型问题，往往一些代码依赖于特定的类型，当导入装饰器时会出现问题？（不是继承吗？怎么回事？）
3. 代码复杂度问题，实例化组件时非常麻烦
## 4. 工厂模式与抽象工厂模式
### 4.1 工厂方法模式
除了使用new之外，还有很多制作对象的方法。
使用工厂模式批量地制作对象

当某一个类的派生子类出现的情况越来越多时，此时我们就需要考虑使用工厂模式来做了，将所有制作的参数来封装。只需要引入某个类型参数即可创建对应的需要的对象。

静态工厂： 仅仅只管理各种不同的类的创建，因此不需要创建对象的方法来实例化对象。

但是，一般来说工厂可能还会封装一些其他属性以及方法，因此就不能通过继承来改变创建方法的行为了。

感觉上都是运用了父类对象可以直接访问到子类对象的多态来做的

实现一个接口，即实现一个超类型

由工厂进一步扩大的要求，不止有建工厂的需求，还希望能够管理加盟店。加盟店还要给下面的店一些自己操作的空间，那么将不变的封装在加盟店中，将改变的部分给下面的店进行继承实现。
> 如果加盟店为一个抽象类，那么如何展示这个店的所有权呢？
因为，所有加盟店体现为加盟店的所有子类，所以所有子类可以整个看成是加盟店，这样就特别自然


#### 4.1.1 组成
- 创建者类
    - 工厂方法, 抽象类，将关键的创建方法设置为abstact,由具体的子类来决定如何创建
    - 具体的加盟店，定义具体的创建方法
- 产品类
    - 具体的产品，实际可以供选择创建的产品

#### 4.1.2 评价
将生产知识封装进了创建者，使得剥离了很多。
特别有意思的东西就是实际上的想法是通过抽象类之间方法的调用从而实现了工厂方法。

OO一个原则是针对接口编程，不针对实现编程。工厂方法所在的思想是将创建兑现的代码集中封装在一个对象或方法内。从某种意义上说，此时就不是具体的类的创建，而是根据参数创建对应的类，从某种意义实现了面对接口编程。但是，对于对象的创建是现实的，不可能永远不创建对象，否则就无法建立java程序，所以不要走向极端。

#### 4.1.3 辨析
简单工厂 vs 工厂方法
简单工厂只是将创建方法进行提取，工厂方法是将创建方法重新作为了一个类的方法
简单工厂把全部的事情在一个地方处理完了，而工厂方法却是提供了一个框架，让子类决定要如何实现

? 字符串传入参数化的类型有点危险
可以通过创建代表类型的对象或者enum类型
? 工厂方法和创建者是否总是抽象的
不，可以定义一个默认的工厂方法来产生某些具体的产品，这样一类，即使创建者没有任何子类，依然可以创建子类。

### 4.2 抽象工厂模式

其实，要实现工厂模式，我们还有一个简单的版本，即实现一个具体类，这个具体类中有函数createPizza(style, type), 但是这有一个问题，这个具体类会依赖于大量的类。

<font color='red'>要依赖抽象，不要依赖具体类</font>

？为什么要依赖一个抽象类呢，感觉上是因为抽象类一般都是包含固定的实现或者接口，是不会改变的地方，比起具体的类而言。

在高层和低层组件之间加上一个抽象类，很完美地体现了依赖倒置原则。

依赖倒置设计指导原则
1. 变量不可以持有具体类的引用：如果使用new，就会持有具体类的引用，可以改用工厂来改变这样的做法
2. 不要让类派生自具体类，有派生必然产生依赖，请派生自一个抽象或接口
3. 不要覆盖基类中已实现的方法。

依赖倒置设计原则的应用环境： 所依赖的具体类是一个极易改变的类，当依赖的是一个不会改变的类时没有必要遵循依赖倒置原则


扩展：设计原料工厂
这里扩展了一个原料工厂的接口，它是单独的，不受任何依赖。然后具体的pizza会拥有原料工厂作为属性，在自己进行创建时经过原料工厂的手来进行创建。
然后，pizza具体工厂会在函数中拥有原料工厂的变量，即在创建时以便将原料工厂传给具体的pizza作为参数

其实，这里原料工厂用来管理各种原料的生产和前面pizza工厂用来管理各种不同的pizza的创建的想法是一样的。这里称为抽象工厂模式。

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
> 抽象工厂方法用来创建一种特定的具体的产品，具有某种属性的东西

#### 4.2.1 辨析

抽象工厂模式: 与工厂方法相比来看，抽象工厂定义了一系列的步骤，产品的操作，每个产品都有createProductA()方法。 而每个createProduct()方法的实现实际上是考虑了工厂方法的。即将其交给各自的具体的实现类来管理使用哪种原料。
而原料工厂提供给pizza工厂的接口就是自己
原料工厂提供给pizza的操作就是各种的createProduct方法
> 在这里其实每个原料工厂是进行了封装了多种特定的方法。暂时代码没有能够实现多个原料工厂的混搭，从某种意义上上层再建一层抽象或者参数给传递多一点可以实现


抽象工厂 vs 工厂方法
创建对象上，抽象工厂使用的是组合；工厂方法使用的是继承
对于抽象工厂来说，如果扩展这组相关产品，必须要修改接口
抽象工厂是被用来创建整个产品家族的，工厂方法不过是创建一个产品。

抽象工厂：创建产品家族和想让制造的相关产品集合起来是
工厂方法：将客户代码从需要实例化的具体类中解耦
## 5. 单件模式
确保一个类只有一个实例，提供全局访问点

### 5.1 前沿
以下情况我们只需要一个对象，线程池、缓存、对话框、处理偏好设置和注册表中的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象。

全局变量的缺点：如果将对象赋值给一个全局变量，那么必须在程序一开始就创建好对象，然而，如果这个对象非常耗费资源，在程序中一直没用到它，就会造成资源的浪费。 JVM: 在用到的时候才创建对象。

如果有多个同时出现，此时就会发生操作系统中学习到的多个进程同时发生的问题了
### 5.2 实现
!!! 居然是通过私有的构造器 + getInstance来实现的
> 不过这样一想也非常合理，如果是共有的必然new会进行不断创建

> ? 不会出现后面给static标志为null的情况了吗？
问题： 多线程运行时会发生同时进入的问题，导致可能分配到不同的对象？
方法：
1. 将getInstance()方法前加入synchronized, 迫使每个进程在进入这个方法之前，必须等候别的线程离开该方法。 但是，同步其实只需要在第一次保证即可，后面的情况不再需要，因此会严重降低性能。
> 如果不重要可忽略
2. 在一开始就创建好实例
3. 双重检查加锁，代码加P182

> 可以扩展为控制实例的个数为指定个

? 为何不直接将所有方法和变量都定义为静态的
> 如果类自给自足，不依赖于复杂的初始化可以这么做，否则静态初始化在java手上可能导致混乱。建议使用对象的单件而不是类的单件
? 类加载器
!!注意不同的类加载器会创建多个单件模式

? 单件模式适合继承吗？
不，因为单件模式的核心是通过私有化构造函数实现的，所以不适合继承。因为子类会进行破坏单件的内容。任何现有的类，都轻易地加上一些代码支持单件模式，但是，单间模式不一定适合设计进入一个库。使用情况并不多

单件模式 vs 全局变量
> 在Java中全局变量就是对对象的静态引用，全局变量有一个很大的缺点就是急切实例化，而且全局变量可以提供全局访问，但是不能确保只有一个实例。 单件模式，有点像静态变量static, 不过声明的时间和位置可以任意，这点超级棒！
## 6. 命令模式
外界显示的接口为命令模式，即将实际的方法进行进一步的封装。将方法调用封装起来。
> 思考这样一种场景，顾客下了一份订单，订单经过服务员然后交给厨师长，然后厨师长进行做菜。其中服务员无须知道订单内容是什么，只需要接收订单并传递给厨师长即可。于是服务员和厨师长之间就彻底解耦了，服务员只需要将订单给厨师长，厨师长则只需要按订单来做

又如前面的问题，让用一个遥控器实现所有设备的自动打开什么之类的。此时遥控器的实现要求不能知道太多细节，有点像订单？

模型是发出请求的对象和接收与执行这些请求的对象解耦

> 然后想到这里的服务员其实只有两个动作，一是接收命令setCommand(这里使用了Light作为参数)，表示添加了一个接收者，二是触发动作。 ? 订阅者模式。 不对！有区别。 这里是一个可能有着多条不同的命令，从命令的模式进行封装。这里就把服务员
直接抽象为命令。于是就形成了各种命令，一下子所有问题变得非常简单了。

// 等于说Command有多种不同的变体，然后client做到了解耦，即只需要关心所有Command共有的两个操作即可。而所有的Command的具体实现对具体的Receiver进行了封装。

扩展？ 如何做撤销
如何实现队列、日志和支持撤销的操作

为了避免检查，很多时候会考虑设置空对象来做。可以更方便地表示!!!!

实现undo操作，在类中设置一个变量用来跟踪最后一个命令。

? 如何控制不再是一个的操作
将RemoteContrl的参数变为数组类型，即所谓的宏命令；或者另一种方式，硬编码；但是第一种宏命令更为灵活
? 为何命令对象不直接实现execute()方法细节
这样就不够傻瓜，换句话说达不到想要的解耦的效果
? 如何保存多层次的撤销记录
不再使用变量，而是考虑使用一个堆栈来做到保存所有的历史记录

### 6.1 扩展
如何实现线程池？即收集多个队列的线程请求，然后有效地把输出限定在固定数目的线程中进行。
> 1. 如何控制每次线程数目是一定的？比如说总共只有4个线程。可以考虑在RemoteContrl中设置属性记录线程的数目，使得线程的个数不会超过指定个数
> 2. 如何存储请求？将请求按单元存储在队列中

日志请求
> 某些大项数据机构的动作的应用无法在每次改变发生时被快速地存储，那么就需要使用记录日志，将上次检查点之后的所有操作记录下来，如果系统出现故障，则从上次的检查点从做。
> 某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。这里通过新增两个方法store(), load(). 在Java中，可以利用对象的序列化实现这些方法，但是一般认为序列化最好还是只用在对象的持久化上。
如何做呢？ 
如何做？这里的感觉就是栈式保存检查点的信息，或者直接将其写入文件，通过对文件内容的解析从而达到目的啊。
## 7. 适配器模式与外观模式
### 7.1 适配器模式
将底层可被调用的类的接口转变为目标类的接口，依此实现不同的接口。
将对象包装起来以简化其接口。

装饰器可以把一个方块放进一个圆洞里面
面向对象的适配器像交流电适配器，用于在中间将客户的请求转变为厂商能理解的请求。
> 简单理解就是一层封装，即把系统的接口封闭起来，向外提供的接口是用户感兴趣的接口

一个例子，需要鸭子，鸭子可以飞，而且可以呱呱叫。但是没有鸭子，只有火鸡，火鸡可以飞和咯咯叫，现在想办法用适配器来冒充提供鸭子的接口


适配器实现了目标接口即鸭子，并且持有被适配器的实例

? 适配器需要做多种适配的工作
如果不采用适配器的话，需要话很多力气来做大量的调查工作和代码改写工作。相比之下，提供一个适配器类，将所有的改变都封装在一个类中，是比较好的做法。
? 一个适配器只封装一个类吗
不，现实情况下，被适配器有很多种，比如同种需求往往有种多种实现，而且后面可能进行增加和删除实现，所以提出了适配器需要适配多个被适配者，就是下面介绍的外观模式。
? 如果既有新的适配要求，又有旧的适配要求怎么办
实现双向的适配器，于是该适配器都可以用，怎么写????

#### 7.1.1 对象适配器和类适配器
类适配器使用的是继承适配类和被适配类得到的，而对象适配器是通过组合得到的。
对象适配器可以适配某个类及其所有子类。
对象适配器只需要组合的对象是子类即可。
类适配器的好处在于代码少，可以覆盖被适配者的行为，而且可以直接继承自适配器

#### 7.1.2 真实世界的适配器
在Java中elements()方法会返回一个Enumeration来，这个接口可以逐一地遍历集合中每一个元素，而不需要知道在集合内是如何被管理的。
迭代器的实现也可以看作是适配器。

#### 7.1.3 适配器 vs 装饰器
适配器允许客户使用新的库和子集合，无须改变“任何”代码。一定会进行接口的转换。
装饰器只是扩展所包装对象的行为或责任，而且绝对不会进行接口的转换
### 7.2 外观模式 Facade-Pattern
改变接口的新模式，改变接口的原因不过只是为了简化接口
外观只是提供你更直接的操作，并来讲原来的子系统组个起来。如果你需要子系统类的更高层功能，还是可以使用原来的子系统。

如何不要赢得太多的朋友和影响太多的对象
只调用以下范围的方法
- 该对象本身
- 被当做方法的参数而传递进来的对象
- 此方法所创建或者实例化的任何对象
- 对象的任何组件
> 如果某对象是调用其他的方法返回的结果，不要调用该对象的方法

实际世界中并不总是满足这个原则的，比如System.out.println??; 因为这样设计会导致非常多的包装类，加大复杂度和开发时间
## 8. 模板方法模式
### 8.1 模板方法模式
主要是为了封装公有算法而产生的，使得对于类型都适配

例子：设计封装煮咖啡和茶的算法。如何做？设计一个接口，分别包含茶和咖啡的所有公共部分的操作，然后算法直接调用它，咖啡和茶则继承自它。
这里接口也可以是抽象类

对模板方法进行挂钩，钩子实际上是一个默认的方法实现。有了钩子，通过自己决定是不是需要覆盖方法，如果不提供自己的方法，抽象类会提供一个默认的实现

? 什么时候使用抽象方法，什么时候使用钩子
> 当子类必须是某个实现时使用抽象方法。 使用钩子的场景：钩子是用来让子类实现算法中可选的部分，或者狗仔对子类的实现并不重要的时候；以及让子类有机会对模板方法中某些即将发生的步骤做出反应

### 8.2 好莱坞原则
防止依赖陷阱，别打电话给我，我会打电话给你们
允许低层组件挂钩到高层组件上，但是高层组件会决定什么时候和怎样使用这些低层组件

模板方法中的体现，抽象类为高层，Tea,Coffee为低层，如果Tea和Coffee没有先被调用，绝不会调用抽象类？
> 抽象类作为高层，只有当Tea先被调用时才可能调用自己，这就由高层决定了什么时候使用，不过这不本身就是多态允许的吗??

### 8.3 应用
1. 排序算法
sort()方法是Arrays类的一个静态方法，然后由用户自己设计类，并实现CompareTo接口，利用对象数组即可实现排序。这也是模板方法模式的一种变形。
> 注意到并没有使用一般的继承来做到，实际上的做法是利用了数组。然后和静态方法来做

模板方法模式 vs 策略模式
> 在策略模式中，所组合的类一定是实现了整个算法，而对于模板方法模式，所实现的算法并不完整
> 策略模式定义了一个算法家族，这些算法都可以进行互换，正因为每一个算法都被封装起来了，所以客户可以使用不同的算法。

2. 写一个SWing的窗口程序
JFrame本身不做任何事情，当你继承它后，并覆盖它的paint类就可以做一些事情了 

## 9. 迭代器与组合模式
迭代器模式，将集合的实现进行封装起来，仅给用户提供遍历的接口。 对象职责？ 创建对象超集合？

> 封装集合

不封装的坏处，必须知道各个部分的物理实现方式，知道的细节多，同时也非常不利于代码维护

本身可以是各种各样的数据结构，例如：列表、数组、散列表等等，无论什么方式存储，一律可以视为集合，有时也称作聚合

- hasNext()
- next()
- remove()
! 多线程下小心，如果是这种具有写操作类似的感觉。即remove, 那么可能会发生多个迭代器引用同一个对象集合，从而会产生冲突

架构：
Iterator,  ConcreteIterrator一个具体的迭代器，然后再关联一个具体的类ConcreteAggregate(由createIterator()来函数返回值关联)。
ConcreteAggregate同时扩展自Aggreate(createIterator())接口的类。
所以 Clint 只需要使用Aggreate接口即可访问任意的ConcreteAggreate
> 评价，首先通过第一次接口的使用，屏蔽了具体的类型；第二次接口，屏蔽了具体的存储实现。所以，迭代器模式很完美地做到了解耦！！

? 内部迭代器和外部迭代器
> 迭代器模式是外部迭代器，内部迭代器由迭代器自己控制。
? 元素读取的顺序问题，如散列表
> 看实现，没有假设有顺序，是无顺序的
? Enumeration
> Enumeration是一个有次序的迭代器

如何评价高内聚??
单一职责?


Java 5: for(  in )
> 不再需要迭代器模式了

### 9.1 组合模式
树形结构，能够按顺序访问到所有的叶子节点
! 忽略对象组合和个别对象之间的差别
> 就是一种变形的迭代

结构:
> 组合包含组件，组件有两种：组合和叶节点元素

? 在组合中用到了迭代器
> 其实说到底的感觉不过就是接口，然后接口有些方法其他地方不用去实现
? 共同接口, 一个类两个功能，从某种意义上说违反了单一原则
> 但这是设计上的抉择，这样做失去了一些"安全性“,但是透明性transparency更好。，另一种想法是使用两个接口，单功能来表示，但是失去了透明性，客户的代码必须用条件语句和instanceOf操作符处理不同类型的节点

> 有些时候为了保证透明性，不得不去牺牲一些其他的特性

? 应用
> 用户界面来说，一个顶层的组件（Frame或Pane)包含着其他组件（菜单、文字面板、滚动条、按钮），所以你的GUI包往往包含了若干部分，但是但你显示它的时候，你认为它是一个整体，由顶层组件显示所有相关的部分
? 有些对象没有的特性
> null或者false, 具体看需求。
? 为何不对孩子节点也设置getChild(), 不过返回为null
> 失去了本身的一些特征，会产生一些没有意义的调用，失去了组合模式的感觉
? 结构特性
> 孩子不会反指向父亲；需要注意孩子遍历的顺序的问题；当组合结构很复杂，遍历代价很高时，可以考虑焕春
## 10. 状态模式
状态模式 vs 策略模式

策略模式是围绕可以互换的算法的创建成功业务的。
状态模式依赖的是状态以及状态之间的改变

自动糖果机

> 一个类一个状态? 一个类一个状态机?

如何思考?
- 首先，得到所有的状态
- 分析出所有状态之间的转换关系，注意一些陷阱
- 设置标志变量
- 分析每个状态之间的转换过程，并对其他的过程进行分析

初试设计，每个状态实际上一个方法，现在考虑扩展方法
1. 扩展，10%的概率奖励购买的人，如何做？
> 标志变量需要扩展，标志变量实际上这里可以看作是类本身的属性

感觉，改进了什么？
> 将有问题多判断以及不好管理和扩展的if语句，改为了对象的形式

### 策略模式 vs 状态模式
> 从类图上看，这两者的类图完全一致，但两者有很大区别
1. 状态模式，往往直接将主体分为状态，把行为附加到状态上；所有的状态模式都会一起相互作用，在主体context下完成工作，是和的作用; 适用于context中多太多的条件判断的替代
2. 策略模式，仅仅是某一步的行为或属性，可以有多种替代方式。策略模式，只要求选其一即可;适用于仅仅继承某个行为的类的优化方式。

? 如何决定下一个状态的
> 这种设计模式必然带来了会在具体的类和context类中共同改变状态，所以产生了很强的依赖，这里的改进就是应用getter方法而不是硬编码的形式把依赖降到了最小。 

? 客户会直接和状态交互吗？
> 不会

? context有多个实例，如何共享对象
> 这里考虑的方法是利用context引用来做，状态对象不能持有自己的内部状态，否则不能共享?

### some question
? 会带来类的数目的增加
> 对，显然的！可维护性和扩展性的折中

? 为什么要WinnerState, 不直接放在SoldState中
> 确实代码上很多重复，这里我们依据的想法是一个类一个责任，即OO原则之单一职责原则

? 如何清掉重复代码以及将糖果机用到其他机器上
> 接口改为抽象类，封装外部可见和内部可见的一些知识

## 11. 代理模式
白黑脸游戏，你是一个白脸，很友善地为别人服务，但你不希望每个人都叫你做事；于是你找了个黑脸，来控制对你的访问。这就是代理所做的事情：控制和管理访问，为某些懒惰的对象做一些事情

当你的重心在糖果机上时，其实是在接受外部消息时，对你的通信线路强插一脚，过滤调用和访问的内容。
> 所以这里就好像在糖果机上套了一个监视器，当实际一细想，是谁在使用糖果机，用户啊? 而目标在于设计糖果机监视器。该视角太难，所以想到转变视角，在糖果机监视器的角度想。

> 然后就产生了很神奇的东西，对于糖果监视器，用户直接使用我，我来处理一些东西，然后我再远程调用糖果机，做真正的处理。所以，远程调用就对用户来说透明了!!!

RMI: 远程调用
> 实际上的做法感觉上其实就是 被调用方变成可调用方法
> 然后，会有一个平台进行实时监控。当收到调用方的调用命令时，然后调用调用方法返回给调用者。
> 也可以不是实时通信，像邮件系统投递一样，调用方和被调用方都有辅助对象。说起来有点像观察者模式中消息传递的感觉

RMI
- stub客辅助对象
- 服务辅助对象skeleton

#### 服务端
三步走
- 总览
    - 制作远程接口 MyService.java
    - 实现具体的远程类 MyServiceImpl.java
    - 使用rmi, 产生该具体类的stub, skeleton
    - 启动rmi registry 注册表
    - 开始远程服务，本地得有一个具体的远程类的一个实例， 将实例加到注册表中 

1. 制作远程接口
    - interface MyRemote extends java.util.Remote{}: 接口可以继承接口
    - 声明所有的方法都会抛出RemoteException异常
    - 确定变量和返回值都是原语类型或可序列化对象
        > 原语类型，即java本身自带的类型，即基本类型。可序列化对象，即实现了Serializable接口
2. 制作远程实现
    - 实现远程接口, 并且对象具有某些远程的功能
        > public class MyRemoteImpl extends java.rmi.server.UnicastRemoteObject implements MyRemote
    - 设计一个不带变量的构造器
    - 用rmi registry注册该远程接口的实例化对象。使用java.rmi.Naming的静态rebind()方法
        > Naming.rebind("RemoteHello", service) 当绑定具体对象时，rmi会把服务换成stub注册在registry, 因此远程客户就能很轻易找到
3. 产生stub和skeleton
    > rmic MyRemoteImpl.  将会产生_stub.class, _skel.class两个对象
    > 命令行需要先编译为class文件
    > 注意要在targets/classes中执行，加包的名称 
    > !!! 现在不再产生_skel类了  
4. 执行rmiregistry
    > 开启一个终端，启动remiregistry, 确定目录必须有可以访问你的类
    > 命令找不到 https://stackoverflow.com/questions/26197749/cant-find-rmi-registry
    > http://www.voidcn.com/article/p-ajxdfmab-ux.html 一种另外的方式
    > 需要在target/proxy中进行启动， 即所在目录，启动方式为类当前目录
5. 启动服务
    > 开启另一个终端，启动服务 java MyRemoteImpl
    > 直接使用idea中运行！！

### 客户端
1. 在rmi registry中寻找
2. rmi registry 返回stub对象
3. 调用服务stub, 此时stub看起来就好像是真正的服务

### 评价
> 这种方式其实有点低级，相当于首先一个窗口执行rmiregistry表示开始了中间的监听，然后一个窗口执行服务器端程序。
> 现在来说，更普遍的方式为“动态类下载”，利用动态类下载，序列化的对象被贴上一个url保险。只需要一个简单的web服务器来提供这些类文件即可。
### 注意
1. 启动rmiregistry
2. 服务端，参数和返回值都必须可序列化
3. 记得产生stub类

### 应用：设计Gumball的代理模式
1. transient 关键字, jvm不需要序列化这个关键字
> can't find the .._stub.class ??

由此可见，通过调用代理的方法，远程调用可以扩月网络，返回字符串、整数和State对象。而此时GumballMonitor并不知道是使用了代理。
> !要特别注意处理远程异常

类图组成
> 注意观察就可以发现，这里的类图组成实际上就是一个接口，然后有两个继承类，一个RealSubject, 一个Proxy, Proxy持有Subject的引用，所以必要时它可以请求转发给Subject.

### 进一步应用：虚拟代理
1. 远程代理
> 远程代理可以作为另一个JVM对象的本地代表。
2. 虚拟代理
> RealSubject创建开销大，所以在创建的时候，先用一个代理来接收请求委托，当创建好了后再进行显示
> 很常见的例子就是网络在加载一个大的视频的时候，通常会由一个正在缓冲的图片来代理显示
> ? 未请求到图片，也没有错误信息

### question
? vs 装饰器
> 目的不同，装饰器是为对象增加行为，而代理是控制对象的访问，可以代表对象，而且处理比对象更多的内容，代理将用户和RealSubject解耦了;
> 装饰器还有一个很大的点就是装饰器永远都不会实例化对象

? 如何让客户使用代理，而不是真正的对象
> 常用的技巧是提供一个工厂接口，实例化返回主题，实例化的工作由工厂来做

? 能不能把加载过的图像放在缓存中
> 可以的，即缓存代理Caching Proxy; 缓存代理会维护之前创建的对象，当收到请求时，在可能的情况下返回缓存对象。

? vs 适配器
> 保护代理有点类似。适配器肯定接口不一样，代理则随意

### 动态代理
- 动态代理
> java.lang.reflect java反射机制其实本身就是代理的彻底体现
> 大概的感觉这里就是java本身为你实现了各种的代理proxy,但是代理的工作现在我放在哪里呢？ 所以java设计了InvocationHandler接口invoke()方法，你只需要实现该接口即可。使用该接口的具体类感觉上就是是代理的方法调用一样的感觉

how to do?

1. InvocationHandlerImpl, 构造函数参数为Target， handler()方法
2. 使用时, 通过Target = (Target) Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), new InvocationHandlerImpl(object))得到

! 动态指的是运行时才将类给创造出来，代码开始执行时是不存在的
? 如何判断是否是代理类
> isProxyClass()方法

? newProxyInstance()类型有什么限制吗
> 只能有接口，并且属于同一个package? 具体看javadoc

! 改变
> java5的RMI和动态代理搭配使用，不需要stub,skeleton都不要了，rmic也不需要了

- 保护代理

> 一个约会软件的例子。 PersonBean有两个访问权限：1. 别人不可以修改自己的特别信息 2. 自己不可以修改别人对自己的评分
> 其实说到底感觉更像是一种访问权限的控制的事情

### 代理使用启示

1. 防火墙代理
2. 智能引用代理：当主题被引用时进行额外的动作，比如计算一个对象被引用的次数
3. 缓存代理： 为开销大的运算结果提供暂时存储?，常在Web服务器代理，以及内容管理和出版系统中出现
4. 同步代理Synchronization: 在多线程的情况下为主题提供安全的访问，被发现出没于JavaSpaces, 为分散式环境内的潜在对象集合提供同步访问控制
5. 复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。外观代理。就是可能直接访问接口太多，代理的话可以只显示一些东西。与外观模式不一样，外观模式只提供一组接口，并不能对原本的对象产生影响。而且远简单于该方式。
6. 写入时复制代理: 用来控制对象的赋值，方法是延迟对象的赋值，知道客户真的需要为止，lazy计算

## 12. 复合模式

!!!, 模式之间进行一起使用

鸭子，不同行为的鸭子；
混入鸭子的鹅， 适配器模式
统计鸭子的叫声， 装饰器模式
统计鸭子叫声的工厂， 工厂方法模式
一个鸭子接口可以控制所有鸭子叫，组合模式 + 迭代器模式（一般是默认实现好的，所以这里就直接用即可）
需要跟踪某个鸭子实时的叫声，即监听，订阅者模式 !!! 
> 关于组合的订阅者??

? 上面就是复合模式吗
> 不只是模式的组合而已

!!! 不要为了使用模式而使用模式
> 上面的例子只是为了演示而已，一定要避免陷入里面去

### 复合模式之王: MVC

视图： 
模型：应用系统存在的理由，设计的对象包含了数据、逻辑和其他在你的应用领域出现的问题

视图：用来显示和编辑的部分

控制器：模型和视图之间的数据流动

用户查看视图，获得的试图的结果传给控制器。控制器做两步工作，第一步，改变显示。第二步，改变数据的状态。 然后，显示是订阅了模型的内容的，所以问询问模型，模型一旦更新完毕。显示进行对应的更新。

> 模型可能要求视图产生变化

? 控制器可以便曾模型的观察者吗？
> 可以的

? 控制器主要就是作为模型和视图之间的交互，那么为什么不直接把这样的代码放在视图中，1，这样会使视图的代码变得复杂，视图就具有了两个功能，管理用户界面和处理如何控制模型的逻辑。2. 这么做会造成模型和视图之间紧耦合。

设计模式解析
> 模型利用观察者模式使得控制器和视图可以随着最新状态更新而更新
> 视图为一个对象，可以被调整为不同的策略，而控制器提供了策略。 
> 视图的显示，包含了窗口、面板、按钮、文本标签等，每个显示组件使用了组合模式。当视图进行更新时，只需告诉视图顶层的组件即可。

Java Dj view

代码之间的关系

- model: 负责数据模型部分, 主要是Observable
- controller, 构造参数为model, 拥有view, 同时初始化view;  为view的策略模式部分。
- view: 主管视图，以及定义乡音接口
- 测试： new model,  new controller(model)

### MVC 与 Web

Web中浏览器/服务器模型也很适用于MVC模型
主要涉及

- 客户
- 控制器Servlet
- 视图
- Bean模型
- DB数据库操作层

关系

1. 客户发送http请求给控制器，控制器操作jsp视图，http回应给客户
2. jsp视图，控制器， bean三者关系即MVC

优点

1. 实现了设计上的组件分割，也提供了制作责任的分割。
    > 单一责任有利于专业的人做专业的事

- 进一步可以做的事，在手机上进行扩展
    1. 修正模型完全不需要
    2. 创建Servlet控制器，一个简单的Servlet,接收http请求，并对模型执行一些操作。它需要做的是停止、开始和改变BPM
        > 其实也就是用户希望能够操作的控制
    3. 创建html视图。它会从控制器收到一个JavaBean,从这个Bean就可以得知它所有需要显示的东西。
        > 这里的Bean的感觉其实就是给前端的模型对象的接口

- 步骤
    1. 模型
        > 模型对视图和控制器一无所知。模型只需要知道，有一些观察者需要它通知。这就是观察者模式美妙的地方所在
    2. 控制器Servlet
    3. 建立视图
        > 关于idea部署
        > 1. https://juejin.im/post/5b440ba05188251aad20f5dd  java
        > 2. https://blog.csdn.net/qq_27093465/article/details/63683873 maven, 暂时看来不能混用： 
        > tomcat下载安装https://blog.csdn.net/zhouzezhou/article/details/52450810   中间四之前需要 service.bat install
        > idea 目录机构
        > https://blog.csdn.net/l00149133/article/details/78984083
        > idea配置java web项目，太原始，问题未得到解决！请试图用比较现代的方式。这里的Servlet和form的路径可以由来表示，但是怎么说起来还是有问题的

- 总结
    > 对比前面的浏览器模型，视图不再是经典意义上模型的观察者，它没有向模型注册以接收状态噶变通知。而是当模型改变时，视图间接地从控制器收到了相当于通知的东西。控制器甚至把Bean送给视图，允许视图可以取得模型的状态。
    > 其实考虑到浏览器模型，视图在http响应返回浏览器只需要一个状态信息的更新，随时通知没有意义。只有当页面被创建和返回时，创建视图并结合模型状态才有意义。
    > 1. 策略: 在这里策略对象依然是控制器Servlet, 但它不想传统的做法那样直接和视图结合，而是，策略对象为视图实现行为，当我们想要有不同的行为时，可以直接把控制器换掉
    > 2. 组合: Swing GUI中视图是利用许多图形组件一层一层叠加起来的。但是在这里，则是由网页浏览器呈现html描述。尽管如此，内部还是很类似一个形成组合的对象系统

### 问题

? 组合模型在MVC中， 在！

? 控制器会实现应用逻辑吗
> 不，控制器为视图实现行为。它将来自视图的动作转换为模型的动作。应用逻辑是指管理与操纵你的模型中的数据的代码

? 控制器是中介者模式吗
> 中介者意图是封装两个对象的交互，不让对象之间互相显式引用，是双方的。控制器只是单方的

? 视图与控制器之间的对应关系
> 通常情况下，运行时一个视图搭配一个控制器；也可搭配多个

? 视图不应该操纵模型，实例代码中并没有设限，这样不危险吗?
> 非常对，作者只是为了简单而已。应该这么做，可以使用代理模式，只对部分接口开放

## 13. 与设计模式相除

真实世界中的模式

模式是什么?
> 在某情境下，针对某问题的某种解决方案
广义之， 如果你发现自己处于某种情境下，面对着所要达到的目标被一群目标约束影响着的问题。然而，你可以用这个设计，克服这些约束并达到该目标，将你引领到某个解决方案
特别注意的是这个问题应该是重复出现的问题，因为始终需要衡量的一个东西就是成本。

? 模式的秒速是否由一个问题，一个情境以及一个解决方案构成？
> 不止这些，模式类目的细节：模式类目描述某个模式的意图、动机、可能应用该模式的地方、解决方案的设计以及使用后果

? 首尾改变模式的结构符合我的设计，可以吗
> 模式只是指导方针，可以改变模式来符合你的需求。真实世界的许多实例，都不符合经典的设计模式。不过在文档中最好注明两者之间的差异

? 从哪里取得模式类目
> 设计模式：可复用面向对象软件的基础。23个基本的模式，还有其他将焦点放在不同领域：企业软件、并发系统、业务系统的模式类目

一种新鲜的解说： 实际的问题实际上就是力。世界上所有的问题包含了一组目标和一组约束。取得平衡的方向是光明的方向，约束是黑暗的方向，只有当两者取得平衡时才是你的目标

- 如何学习？
    1. 首先对于模式，知道的越多越好。然后，在实际应用中，一旦三个开发人员认同你的看法，你就成功了
    2. 一个条目所包含的内容
        - Intent
        - Motivation
        - Applicablity
        - Structure
        - Participants
        - Collaboration
        - Consequences
        - Implementation/Sample Code
        - Known Uses
        - Related Patterns

- 模式分类
    1. 创建型: 涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦
        > Singleton,  Builder,  Prototype, Abstract_Factory, Factory_Method
    2. 行为型：涉及到类和对象如何交互分配职责
        > Template_Method, Visitor, Mediator, Iterator, Memento,, Interpreter, Observer, Chain_Of_Responsibility, State, Strategy 
    3. 结构型： 把类或对象组合到更大的结构
        > Decrator, Composite, Facade, Proxy, Flyweight, Adapter

架构模式: 建筑物
应用模式： MVC
领域特定模式： J2EE
业务流程模式: 
组织模式：
用户界面设计模式：

## 14. 剩下的模式

- 桥接 Bridge Pattern
    > 不止改变你的实现，也改变你的抽象
    > ? 不是很详尽，大概的改机是，一个遥控器，一个电视，每个不同型号的遥控器应该都有自己的实现。实际上的做法就是RemoteControl接口，ConcreteControl是抽象类,可以改变，然后TV接口接具体的实现
    > 两者的关系是RemoteContrl拥有TV, TV为成员变量
    > 应用 : ?需要用不同的方式改变接口和实现时
- 生成器 Builder Pattern
    > 封装一个产品的构造过程，并允许按步骤构造
    > 例子：度假计划，每一天都可以由用户自我进行构造； 想法，实现一个AbtractBuilder, 具体生成器隐藏具体的构造过程
- 责任链Chain of Responsibility Pattern
    > 当你想让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式
    > 例子：自动将邮件分发到不同的部门
    > Handler此时就像switch语句的编译实现一样，Handler有多个具体的实现，如果当前Handler解决不了，会一直向后进行自动传递。
    > 优点： 将请求的发送者和接受者解耦; 可以简化结构，不必知道链的实现; 通过改变链内成员或调动他们的次序，允许你动态地新增或者删除责任。
    > 应用： 经常被使用在窗口系统，处理鼠标和键盘之类的事件; 并不保证请求一定会被执行，如果没有任何对象处理它，会落到链尾端。不容易观察运行时的特征。
- 蝇量 FlyWeight
    > 如果想让某个类的一个实例能用来提供许多虚拟实例，就使用该模式
    > 并不实际建立类，比如TreeManager,treeArray来代表所有类的状态，所以存储的只是需要某个内容，比如说显示，只存储位置，而不进行建树
    > 缺点： 一旦实现了它，那么单个的逻辑实现将无法拥有独立而不同的行为
- 解释器? Interpeter Pattern
    > 使用解释器为语言创建解释器
    > 这里的重点好像就是把每条语法设置为类。首先，本身的设计是什么？即首先词法分析，词法分析后进行比对语法分析。所以这里是处理上下文。把每个类当做节点，如果当前节点成功就进行下个语句的解析的意思是吗？
- 中介者 Mediator Pattern
    > 使用中介者模式来集中相关对象之间复杂的沟通和控制方式
    > 使用中介者来管理两个对象之间的相互交互
    > 常用来协调相关的GUI组件?? 如何做的
- 备忘录 MemontPottern
    > 当你需要让对象返回之前的状态时，就使用备忘录模式
    > 出发点是为了保存进度
    > 存储系统关键对象的重要状态
    > 维护关键对象的封装
- 原型 ProtoType
    > 当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式
    > 原型允许你通过复制现有的实例来创建新的实例，在Java中意味着clone方法。从某种程度上说，一要求某类提供静态方法。二要求能够查找正确的复制对象
- 访问者 Visitor
    > 当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式
    > !!! 很精彩，访问者可以参观组合中的每个元素，由它来管理外界对该组合的访问。由此，外界需要使用该组合时，可以直接考虑使用访问者。如此，当想在组合中增加一些对象时，只需要在访问者接口中进行相应的注册即可

> 怎么从类图看依然还是不会

思考：

1. 解决什么问题？什么条件
2. 一般的解决方法是
3. 如果过渡到设计模式
4. 设计模式是什么，类图关系，如何做到解耦的?
5. 优点和缺点分析
6. 实际场景介绍