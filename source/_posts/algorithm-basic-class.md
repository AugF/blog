---
title: algorithm basic class
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-16 08:02:32
tags:
- algorithm
- acwing
categories:
- [algorithm, acwing, sumarry]
---

快排
> 难分，易于归并
> eg: 第k个数

归并
> 易分，难合
> eg: 逆序对

二分：整数，浮点数
> 二分，多种场合，分治的取一情况。分割两种不同的性质

高精度,A+B, A-B, A*a, A/a
> A+B, tmp临变量。 末尾存储，a[0]存个位。

前缀和差分
> 前缀和[;,r], s[r]-s[l-1]. 一维和二维。
>一维前缀和
$a_l+a_{l+1}+...+a_r = S_r - S_{l-1}$
> 一次O(n),后面线性时间查询
> 差分: 多次为某个区间中的数进行操作，单位时间即可解决

双指针
> 模板很好用，找单调性

位运算： 
怎么析取每一位1，怎么找到最低位1
> 位操作才是

离散化
>在一个小的区间上反复做操作和查询

区间合并
> 为后面做准备。 怎么处理特殊情况？让情况考虑完全！

单链表和双链表
> 单： e[N],ne[N],idx,head=-1;   e[idx++]=x;  注意！删除头元素！ 数组中自然下标对应的是按顺序插入的值，不考虑删除的情况;
>   > 注意节点的值存储在e[i]中
>   > 常用在图和hash表的存储中
> 双： e[N],l[N],r[N],idx,r[0]=1,l[1]=0;  e[idx++]=x; 从2开始计数，删除时直接用指针即可

栈和队列
> 栈: st[N],tt   st[++tt]=x;  tt?No:Empty
> 队列：q[N],hh,tt=-1  q[++tt]=x  hh<=tt ? No: Empty

单调栈和单调队列（滑动窗口）
> 首先给出暴力做法，然后去掉没有用的元素，发现剩余的元素具有单调性。 没有用的元素考虑使用栈或者队列将其抛弃，剩余的元素则进行保留。
> 对单调性的东西，可以考虑用栈来访问最近最值元素，队列来访问全局最近最小元素？，另外由于单调性还可以用二分法进行模拟。
> 实现：
> 单调栈： 队中存储的就是元素
> 滑动窗口： 队中存储的是元素的下标
> 时间复杂度优化： 每个元素最多进栈和出栈一次，优化为了O(n); 
> ? 二元关系的下界知道，怎么知道一个问题的下界是多少？
```
单调栈
st[N], tt=0;
for(int i=0;i<n;i++){
    int x;
    while(tt && st[tt]>=x) tt--;
    if(tt) puts("-1");
    else printf("%d",st[tt]);
    st[++tt]=x;
}

单调队列
a[N], q[N], hh, tt=-1;
for(int i=0;i<n;i++){
    if(hh<=tt && q[tt]<i-k+1) hh++;
    while(hh<=tt && a[q[tt]]<=a[i]) tt--;
    q[++tt]=i;
    if(i>=k-1){
        cout<<q[hh]<<endl;
    }
}
```

KMP
> 用于搜索模板串在子串上出现的位置，思想是提前对模板串做信息标志，即利用最大后缀。
> next[i]: 以i为终点的，最长连续后缀的长度。  next[1]=0; // 初始化
> 关键为next数组, 时间复杂度, 匹配的时候while不执行和while执行时均摊可以知道，while最多减m次 ？？？
```
for(int i=2, j=0;i<=n;i++){
    while(j && p[i]!=p[j+1]) j=next[j]; //j=0,表示一个都还没成功匹配
    if(p[i]==p[j+1]) j++;
    next[i]=j;
}

for(int i=1,j=0;i<=m;i++){
    while(j && s[i]!=p[j+1]) j=next[j];
    if(s[i]==p[j+1]) j++;
    if(j==n){
        printf("%d",i-j+1); // 返回从1开始的s的下标
        j=next[j];
    }
}
```

Trie树
> 利用相同的前缀，进行搜索；将每个字母当做一个节点。
```
son[N][26],cnt[M],idx; // 这里M应该是最多出现的节点的个数，因为这里M是节点的计数
这里的N是最大出现的层数，即字符串的最大长度。
str[N];

int add(char str[N]){
    p=0;
    for(int i=0;str[i];i++){
        int u=str[i]-'a';
        if(!son[p][u]) son[p][u]=idx++;
        p=son[p][u];
    }
    cnt[p]++;
}

时间复杂度 插入O(n),查找O(n); 可用于在大批的字符串中进行查找
```

并查集
> 将两个元素合并，询问两个元素是否在一起; 用树来模拟
> 1. 如何判断根 2. 如何求x的集合编号  3. 如何合并
> 可用于一切集合合并的问题
```
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}

for(int i=1;i<=n;i++) p[i]=i;

M: p[find(a)]=find(b);
Q: find(a)==find(b);
```

堆
> down(i), up(i); i从1开始， 变小往上走，变大往下走
> 堆排序，建堆O(n), 修复一个元素O(n). O(klogk):找前k个元素？？
> 模拟堆，额外维护一个第几个插入与堆中元素的链表

哈希表
> 注意区别离散化，离散化是借助前缀和来做
> 如何哈希？ 如何解决冲突？ 开放寻址法+拉链法
> 无序性，O(1)
```
关键find函数，找到元素或者找到该插入元素的位置
拉链法
h[N],e[N],ne[N],idx;
int insert(int x){
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

int find(int x){
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i]){
        if(e[i]==x) return true;
    }
    return false;
}

memset(h,-1,sizeof(h));

开放寻址法：找坑法
如何填满了会出问题，所以经验上会用2-3倍空间
const int N=200003,null=0x3f3f3f3f;
int find(int x){
    int k=(x%N+N)%N;
    while(h[k]==null && h[k] != x){
        k++;
        if(k==N) k=0;
    }
    return k;
}
memeset(h,0x3f,sizeof(h)); // 关键null要大于x数值的范围
```


字符串哈希
> 前缀哈希，正常按高到低来。由p进制来转换为十进制数。
> 经验值： p=131,13331, Q: 2^64;
> [l,r]的哈希值h[r]-h[l-1]*p[r-l+1]
> 所以只需要比较两个哈希值是否相等就能知道两个字符串是否相等。如果h和p提前计算好就是O(1),作用快速比较两个字符串是否相等
```
ULL h[N],p[N];
char str[N];

ULL get(int l, int r){
    return h[r]-h[l-1]*p[r-l+1];
}

p[0]=1;
for(int i=1;i<=n;i++){
    p[i]=p[i-1]*p;
    h[i]=h[i-1]*p+str[i];
}
```

STL初步
vector 变长数组，倍增思想 size()
dequeue 特别慢
string 可用作模拟栈, pair
queue(), priorityqueue
stack
set有序序列，基于平衡树实现 O(logN)
map a["adad"]=1, a.count()? 好用！
unorder_set,.._map,哈希，O(1), 单独头文件
bitset(): bitset<10000> s; ~,&,|,^


DFS: 回溯，暴力搜索，恢复现场
1. 简单的框架
```
// 回溯法: u代表了每一层
int dfs(int u){
    if(u==n){
        //print
        return;
    }
    for(int i=1;i<=n;i++){
        if(!st[i]){
            st[i]=true;
            dfs(u+1);
            st[i]=false;
        }
    }
}
```
2. 树和图的框架
```
h[N],e[N],ne[N],idx;
st[N];

void add(int x,int y){
    e[idx]=y,ne[idx]=h[x],h[x]=idx++;
}

// 注意这里是图的遍历框架，所以跟前面的不一样，考虑的不是到达某一显示的层；而是将图中所有节点搜索完得到结果
void dfs(int u){
    st[u]=true;

    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(!st[j]){
            // 预处理
            int t = dfs(j);
            // 后处理
        }
    }
}
```

BFS: 最短路的性质
```
h[N],e[N],ne[N],idx;
int d[N],q[N];

void bfs(){
    // 声明数组

    // 初始化加入第一个元素

    while(queue不空)：
        t<-队头
        枚举所有出边：
            if(constraint(x)){
                更新d[j];
                入队；
            }
    
    // 队列中的元素就是拓扑序列
}
```

最短路问题
- 单源最短路
    - 正权边
    > Dijkstra算法 O(n^3)
    > d[i]=0;  for(i:1-n) min, S<-t, update min
    > 堆优化的Dijkstra算法 O(mlogN)
    - 负权边
    > Bellman_ford()
    > spfa()
- 多源最短路 floyd, 动态规划

最小生成树
Prim算法
朴素版 算法思想
d[1]=0, d[2..n]=INF
while(q.size())
(t=q.min()  for v: t-v: if(!st[v]) d[v]=min(d[v],d[t][v]);)
O(n^2): n轮，每轮1-m
Kruskal O(mlogm)
从小到大选边， mlogm进行排序  

二分图
染色法 O(n+m):对所有边和点进行遍历
匈牙利算法O(nm)
找最大匹配

数论
质数
从2开始具有某种性质的整数； 
判定方法：试除法：d|n, n/d |n,  d<=n/d
分解n的质因数：不断砍质数 <=n/i
筛质数：筛选出2~n之间的所有质数
- 从小到大筛数的倍数
- 筛素数的倍数： 埃式筛法
- 利用乘积来筛：线性筛法 <=n

约数
试除法求约数：成对出现。然后在排序，可以计算出排序的时间复杂度远小于一般情况
约数个数：自然数基本定理 a=p1^a1 p2^a2 ... pk^ak
约数之和：(p1^0+...+p1^a1)(p2^0+...+p2^a2)...  (利用了组合数学)

最大公约数
辗转相除法

欧拉函数 p(n): 1~n之间与n互质的数
如何求？容斥原理，去掉不互质的 N-N/p1-N/p1+..进行统计 N(1-1/p1-1/p2-... + 1/p1p2)
然后公式改写可以得到 N(1-1/p1)(1-1/p2)...(1-1/pk)
- 公式法：计算出某一个数的欧拉函数
- 筛法：计算多个数的欧拉函数
phi[primes[j]*i]=primes[j]*phi[i]  // primes[j]是i的第一个质因数
分为质数
最小质因数是该数的因子
最小质因数不是该数的因子
使用线性筛法的模板来解题

费马定理 a^(phi[p]) mod p = 1

a^k mod p的快速幂: 将等比数列，等差数列之类的东西很容易用循环结构来写，这样从某种程度就会让问题的难度降低很多

快速幂求逆元： aa^-1 mod p = 1  根据费马定理 a^(p-1) mod p=1, 所以逆元为a^(p-2) logP

扩展欧几里得算法 ax+by=gcd(a,b)  求x和y：本身其实是有多个解的，注意这里的循环结构是非常妙的！

线性同余方程 ax =b mod m,  转化为ax-my mod m=b, 然后再扩充解，如果(a,m)|b不成立的话，无解

中国剩余定理： 第一种方法：使用公式法来做；第二种做法：使用线性同余方程的合并来做

组合计数
- 10万组 2000  递推 C(n,m)=C(n-1,m)+C(n-1,m-1) O(n^2)
- 1万组 10^5 运用逆元的思想  fib[a] infib[b] infib[a-b] mod n, N*logN
- 20组  10^18 使用卢斯卡定理 C(a,b)=C(a mod p, b mod p)*C(a/p, b/p) mod p  后面mod p 必须有否则不成立, p这里一般不会太大
- 无模运算：直接求a!中p的个数, 用大整数乘法来做

有序的01序列
卡特兰数，转化为图形，数轴翻转进行理解
(2n)! / n!(n+1)! = 1/(n+1) C(2n,n)
应用很多，如栈的顺序

高斯消元
手动模拟人工计算的工程
1. 对列进行循环
2. 寻找首元素最大的行
3. 如果为不存在或为0， continue
4. 交换最大行和首元素行
5. 将当前行首元素置为1，从后往前循环
6. 将后面的行的首元素变为0
7. 对有多组解、无解、唯一解情况进行判断

异或：不进位的加法
1. 枚举列
2. 找非零行
3. 交换
4. 消零

容斥原理
韦恩图
有什么用？能减少枚举的数量的个数？如果找到某种性质的话
比如：1~n之间能被p1,p2,...等多个数整除的数的个数？使用容斥原理 k(2^k-1) 复杂度

简单博弈
公平组合游戏
Nim游戏： 必败状态=0和必胜状态!=0, 自然数的异或
Nex游戏，sg(x)终止状态为0状态，反推最小非负整数的运算，每一个都是到不了状态
> 每个可以根据形成一个单独图，sg(b1,b2)=sg(b1)^sg(b2)
实例： Nim游戏、台阶-Nim游戏、集合-Nim游戏、拆分Nim游戏

背包问题
- 01背包 i v max(w) 每个物品选或不选
f[i][v]=w: 所有只使用前i个物品且总体积小于v的取法的权重的Max  根据最后一个元素i放或不放进行拆分 f[i][v]=max(f[i][v], f[i-1][v-v[i]]+w[i])
N*V *1  N
- 完全背包 每个物品可以选任意次
f[i][v]=w 所有只使用前i个物品且总体积小于v的取法的权重的Max  根据最后一个元素i取多少次进行限制 由容量大小确定取的次数 根据递推关系可以简单写成 f[i][v]=max(f[i][v], f[i][v-w]+w)
N*V*1 N
- 多重背包问题 每个物品有si个
> 思路将0~si,用1,2,4,..,2^k,c枚举转化为01背包问题
NlogS*V*1 NlogS
- 分组背包问题 每组物品中只能选一个或不选
f[i][v]= N 所有只从前i组中选择且总体积不小于v的取法的权重的最大 根据每组选哪个元素来分类 f[i][v] = max(f[i][v], f[i][v-v[i][k]]+w[i][k]) // k=0~k-1
N*V*K N*K
> 这里用组的概念代替了单个背包，所以也多出了多种选择

线性DP
> 考虑的方式都是线性的

- 数字三角形 从上到下的权重最长的路径
f[i][j] 所有从起点走到(i,j)的路径的权重和的最大值 根据前一方向的来源，左上方还是右下方 f[i][j]=max(f[i-1][j], f[i-1][j-1]) + a[i][j]
n^2*1 n^2
> 因为出口有多条路，所以数据结构不可缩减

- 最长上升子序列
> 注意发现的话，可以看出这里的做法是很妙的
f[i] 所有以第i个数为结尾的上升子序列的结合长度的最大值 考虑上升子序列中上一元素的位置 f[i]=max(f[j]+1) j:0~i-1   n*n n
非DP,优化  n*logn
发现长度的最后一个位置具有递增关系，可以用二分法搜索进行优化
> 代码！！！

最长公共子序列
f[i][j] 所有由第一个序列的前i个字母和第二个序列的前j个字母构成的最长公共子序列的Max 根据第i个和第j个字母是最长公共子序列的结尾元素，优化后可得  f[i][j]=max(f[i-1][j],f[i][j-1], f[i-1][j-1]+1)
N*M*1  N*M

最短编辑距离
f[i,j] 将a[1,i]编辑成b[1,j]的所有操作方式的集合，操作方式有插入、删除、替换 根据最后一次属于哪种操作方式进行分类 f[i,j]=min(f[i-1,j], f[i,j-1], f[i-1,j-1]+(a[i]!=b[j]))

区间DP
> 二维的i,j一般为区间的起始和终点坐标
石子合并 前缀和的运用 大整数相乘
f[i][j] 所有将第i堆石子和第j堆石子合并成一堆石子的合并方式的代价的最小值 按最后一次合并的位置进行划分
f[i,j] = max_k (f[i,k]+f[k,j]+pj) k=i,..,j-1 n*n n^2  
> 这里循环用了len和i，值得借鉴

计数类DP
属性为数量，直接相加得到最终结果
整数划分
f[i,j] 从0~i中选择整数，组成恰好是j的所有方式的集合的总数量 按i加入的次数进行分类 完全背包问题
f[i,j] = f[i-1,j] + f[i,j-v[i]]
ans = f[i,i]

f[i,j] 使用j个元素构成的数恰好是j的所有方式的集合的数量 最小的元素是否是1
f[i,j] = f[i-1,j-1] + f[i-j, j]
ans = sum_i f[n,i]

数位统计DP
比如计数问题，对数位上出现的数进行统计

状态压缩DP
f[i][j], 某一个位使用二进制位来表示整体的状态方程
蒙德里安的梦想
> 非常妙的一种做法，想到每个小格进行递推得到方程式
矩形可以有多少中1*2的小矩形的填充方法，首先考虑横着的矩形，竖着放的矩形就唯一确定了。
对于横着放的矩形，总共的方案数，研究每列上每个状态的情况！！ 多加理解
最短Hamilton路径
为什么要用这个？
f[i][j] 所以从0走到j，走过的所有点的状态是i的所有路径的长度
> 用状态压缩是因为这里的路径不是按自然序来的，可能有多种组合方式

树形DP
没有上司的舞会
容易，直接用父子关系即可建立DP关系
> 注意最大值这里可能会犯错

记忆化搜索
滑雪
> 非常妙的一个东西！对于方格型DP,想到了用方向来分类做，非常好

贪心
证明
A=B: A<=B && A>=B
区间问题
- 右端点排序
1. 区间选点问题，数轴选最少的点覆盖所有的区间
> 排序，从前到后枚举每个区间，ed=-2e9,如果当前区间被覆盖，即区间的左端点小于ed,下一个；否则，更新ed
证明：最小不用; cnt<=Ans, cnt覆盖了所有不相交的点，是基本情况

2. 最大不相交区间数量
> 同上
证明：最大不用；cnt>=Ans, Ans选择的是两两没有交集的区间，那么是点覆盖区间的基本情况，所以必然点的数量大于区间的数量

- 左端点排序
1. 区间选组，选择每组内部不相交组的，所分的最小组数
> 排序， 一定是左端点最大的（意味着不可替换性）L[i] <= 所有组的Max_r，则要开辟一个新的组；否则，选择其中r最小的组进行加入，并更新该组的r
正确性：最小不用；Ans>=cnt  L[i] 成为新组前一定是形成了cnt+1个相交的区间，这些相交的区间必然花费等量的组，于是得证

2. 区间覆盖，给定区间，如何用最少的相交区间将其覆盖，也就是怎么安排可以使得任务量最少
> 排序，在所有能覆盖某一点start,选择最大右端点的，作为新的start，依次类推得到最优解
正确性：Ans<=cnt显然， Ans>cnt, 如果与该算法不同，即选择的不是最右的，那么任何最优的算法均能转换为该算法得到的结果，因此大于。

Huffman树，合并n组东西，如何合并才能使总代价最小。 Huffman树的结构，用层数来解决。

贪心算法

- 排队打水问题
> 贪心题一般是猜一个做法，然后思考为什么是对的。调整法和反对法

调整法，对于其实要满足某种顺序，比如正序或者降序的序列，可以假定有两个不满足该序列，然后从而推出矛盾（因为有目标值的存在）

如果不是按照从小到大的顺序排序，必然存在两个逆序的数。此时得出的结果必然小于交换这两个数得出的结果

- 货仓选址
> 用数学和用函数来进行建模
> f(x) = |x_1-x| + |x_2 - x| + ..
> 猜是中位数
考虑进行分组
二维，基于随机的思路；如果总和变小就有情况获取

- 推公式
> 贪心某种常用的做法其实是推公式，然后使用不等式从而得到最优解
> 均值不等式，调和不等死，柯西不等式，绝对值不等式，几何不等式
> 贪心大多问题都是数学上研究过的问题

贪心得到的答案 >= 最优解
贪心得到的答案 <= 最优解
> 同时比较大小，请注意要学会进行比较。不考虑不变项，然后加上和减去一个无关的变量
> 此贪心的策略只会使最优解结果变小

# 总结
数据结构的使用
最值，堆
区间和，区间数组，树状数组，线段树
有序链表，平衡树，set

技巧：一维转为二维

开始审题很重要，不要什么都没有就往前面跑，首先心理要有一个很好的思路
还有模板哪些步骤一开始只是套路，越到后面越没有必要去实实在在地在意它，这样是完全地浪费功夫的感觉

- 高精度压位
int 2*10^10
加法一般压9位
乘法一般压4位 10000*10000=1e
> 实际上的想法就是在进行高精度计算的时候，一位一位用char来做太费时间和内存了；可以考虑用int来做，
加法9位9位地压，乘法4位4位地压

从高位开始读数： 整个数一直左移
```
char str[7]='121213'
for(int i=0, t=0;i < n;i++){
    s= s*10 + str[i]-'0';
}
```

从低位开始读数
```
char str[7]='121212'
for(int i=0, s=0,t=1;i<n;i++){ // t表示每一位的进制，每位的数乘以每位的进制
    s += (a[i]-'0')*t;
    t*=10;
}
```

DP的属性可以有布尔值之间的传递，长度，最值

DFS 递归
BFS 队列 循环
# 错误
- Segmelut Flait
数组，全局变量局部不可访问
数组长度未开够
使用删代码法


将函数return false; 如果问题未改变，则说明不是该函数的问题
- TLE时间受限
算法出错
局部变量初试为初始化
循环变量名抄错

c++ 
inline 编译器在执行不会将其转化为函数调用，少了函数栈的空间，一般适用于简单的函数
register int 将变量保存在寄存器中 

遍历想想也就两大类啊，深度优先和宽度优先
宽度优先就是层次遍历

宽度优先具有最小的性质，一定能够得出到根节点的最短性。但是宽度优先需要耗费很大的空间，至少存储两层的节点，所以极其耗费空间

深度优先虽然没有最小的性质，但是空间复杂度低，只需要空间复杂度为树的高度的空间

书上的公式是书面语，不是大白话，讲究优美性，实际理解时往往需要抽象我们所理解的大白话。

讲题的境界： 怎么想出来的？正确性

动作记忆！！！

C++中0，NULL，nullptr是一个东西

声音越小越有气势，更重要的是听别人的东西，把别人的东西听懂

## 待做
https://blog.csdn.net/weixin_39778570/article/details/86484020
基本算法篇
- 模拟
- 枚举
- 排序
- 分治
- 二分
- 倍增
- 贪心

链表
指针
二叉树
二叉搜索树

> 二叉搜索树，父节点， 左孩子节点的函数值严格小于父节点， 右孩子节点的函数值严格大于父节点

后序遍历： 左、右、中 
前序遍历： 中，左，右
中序遍历： 左，中，右


## 总结

DFS两种框架

第一种
起始点未定, 用层数来表明，子节点都很清晰
```
int n;
int path[]
dfs(int i){
    if(i==n){
        collect path;
    }

    for(int i=0;i<n;i++)
        if(check(i)){
            p[i] = 1;  //  赋值

            dfs(s);

            p[i] = 0;  // 恢复
        }
}

dfs(0)
```

第二种
```
int st[N];
int path[N];  //?

dfs(int v){
    st[v] = true; // 保证遍历不重复，不需要恢复
    path[i] = f;

    if(end)  collect
    for(w: vw)
        if(!st)  dfs(w);

    path[i] = -1; // 其他变量需要恢复
}

```

BFS的写法
```
int fun( ){

    q.push(v);
    while(q.size()) {
        auto t=q.front();
        q.pop();
        
        for(int i=0;i<4;i++)
            if(check(i)) q.push(i);
    }

}
 // ? 层次怎么体现？？
```

DP的写法

```迭代版
f[0][0] = ?
for(i:1~n)
    for(j:1~m)
        f[i][j] = f[i-1][j-1]

cout<<f[n][m]
```

```记忆化搜索,递归版易于理解

int f(int i,int j){
    if(f[i][j]!=-1) return f[i][j];
    if(base) {
        初值
    }
    res=?

    for(i:1~n)
        for(j:1~m)
            res=f(i-1,j-1);
    return f[i][j]=res;
}


dfs(0,0)
```

```自顶向下版
dp[0][0]

bool dp(int i,int j){
    if(f[x][y]!=-1) return f[x][y];
    if(base) {
        return ; // 这里一般是f[i][j]具有某种具体含义的，比如两个字符串匹配，A的前i个字母和B的前j个字母这类极大值情况具有意义的
    }

    dp[x][y] = dp[x+1][y+2] // 看这里的状态是否好推演
}
```

DP集合划分的方式总结
