---
title: design pattern summary
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-18 18:51:43
tags:
- java
- design_pattern
- summary
categories:
- [java, design_pattern, summary]
---

参考书籍： head first 之设计模式

相关实现代码： https://github.com/AugF/DesignPatterns

## A. 概览

1. OO基础
    - 抽象
        > 基类，类的定义
    - 继承
        > 在设计模式中体现，父类和子类的多态
    - 封装
        > 类本身的定义，类封装或者函数封装
    - 多态
        > 参数，返回值多态
        - 运算符多态

2. 类代码可控制的点
    - 访问控制
        > 保护，公有，私有
    - 单例方法，类的方法
        - 静态变量
        - 单件模式
    - 多态
        - 函数参数多态
        - 函数返回值多态
        - 操作符多态
    - 变量类型
        - 引用
        - 常量
        - setter, getter类 

3. OO原则
    - 封装变化
    - 多用组合，少用继承
    - 针对接口编程，不针对实现编程
    - 为了松耦合而设计
    - 类应该对扩展开放，对修改关闭（开闭原则）
    - 要依赖抽象，不要依赖具体类（依赖倒置原则）
        > 不要让高层组件依赖于低层组件
    - 最少知识原则，只和你的密友谈话，和Law of Demeter一样的意思
    - 好莱坞原则：别调用我们，我们会调用你们
    - 一个类应该只有一个引起变化的原因（单一原则）
        > 还有一个概念叫内聚，用来度量一个类或者模块紧密地达到单一目的或责任。 单一原则要求高内聚


4. 原则总结
    - 类本身
        - 单一职责
        - 封装变化
        - 对扩展开放，对修改关闭
    - 类之间的关系的目标
        - 松耦合
        - 最少知识(和很少的类交互)
    - 类之间关系的设计
        - 思想
            - 多用组合，少用继承 
            - 针对接口，不针对实现
        - 物理
            - 依赖抽象，不依赖具体类
            - 掌握主动性, 主动发出，而不是被动接受


5. OO方法
    - 策略模式: 接口实现动态的方法
        > 定义算法族，分别封装起来，让它们可以互相替换，此模式使得算法的变化独立于使用算法的客户. 委托即接口
    - 订阅者模式: 出版者和订阅者
        > 在对象之间定义一对多的依赖，这样当一个对象改变状态时，依赖它的对象会收到通知，并自动更新
        > 窗口添加监听对象
    - 装饰器模式: 开闭原则的唯一实现??
        > 动态地将责任附加到对象上。想要扩展功能，装饰器提供有别于继承的另一种选择
        > 永远都不会实例化对象
    - 工厂方法模式：完成多种类别的对象创建的封装
        > 定义了一个创建对象的接口，但由子类来决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
        > 输入目标返回实例
    - 抽象工厂模式：创建一个家族
        > 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    - 单件模式: 有益于随时随地地使用全局变量
        > 确保一个类只有一个实例，并提供一个全局访问点
        > 使用vilatile static Singleton uniqueInstance， vilatile关键字要求当uniqueInstance初始化为Singeleton时，多个线程需要正确处理它
    - 命令模式： 封装命令的具体形式, 日志的记录，其他的操作实际上就是写入文件, 面板的按钮引起操作
        > 将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销操作
        > 具体实现就是，User中, sendCommand(command), buttonPressed事件触发command.execute(); Command将对其他的一些复杂操作完全包括在自身execute中
        > 单独将方法抽出来成为一个类
    - 适配器模式: 接口解耦
        > 将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
    - 外观模式：操作的简易化封装
        > 提供了一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    - 模板方法模式： 封装算法
        > 在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法可以在不改变算法结构的情况下，重新定义算法中的某些步骤
    - 迭代器模式： 封装集合，顺序访问接口
        > 提供一种方法顺序访问聚合对象中的各个元素，而又不暴露其内部的表示。
    - 组合模式： 同等方式对待整体和部分中的每一个元素
        > 允许你将对象组合为树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。
        - 两个版本： 透明式和不透明式
    - 状态模式：通过引用不同的状态对象，将不同行为委托给所对应的（当前的）对象。
        > 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
        > ! 内部状态改变时，改变它的行为实际是就是将将行为委托给状态。因为本身引用到多个不同的状态，所以可以来类好像产生了改变，实际上是由行为引起转向了不同的状态对象
    - 代理模式: 用于输入对象的过滤. Proxy代替RealSubject处理外界输入
        > 为另一个对象提供一个替身或占位符以控制对这个对象的访问
        > 使用代理模式创建代表对象，让代表对象控制某对象的访问。被代理的对象可以是远程的对象、创建开销大的对象或者需要安全控制的对象。
        > transient A a; 声明类中a属性不用序列化
        > 虚拟代理的例子中，加载图片涉及到新开一个线程
        - 特性
            > 代表对象和以及处理相比于对象更多的东西
        > 只允许访问部分接口
    - 复合模式
        > 复合模式结合两个或两个以上的模型，组成一个解决方案，解决一再发生的一般性问题
        > 注意！ 简单的叠加不叫复合模式，复合模式是一个对象同时参与到多个模式中。


## B. 常见模式总结

1. 全局变量： 单件模式
    > 实现： 变量标志，关键字控制多线程，即模板
    - 测试： 全局只有一个锅炉
2. 接口不匹配： 适配器模式 
    - 类适配器
        > 原本的类没有，只有新类
        > Adapter实现目标类Duck的接口, Adapter构造参数为要替代的类Turkey, 然后实现Duck的接口
        > 实际使用时用Adapter当做Duck使用
    - 对象适配器
        > 实现目标类的接口或抽象类，不过只需要覆盖方法即可
    - 测试： 火鸡的接口来冒充鸭子的接口
3. 可变子类太多： 装饰器模式
    > 抽象接口, 两类扩展接口，一种是基本的元素类（必需品）, 一种是可扩充品，参数为该接口本身, 添加一些东西，对要计算的值再计算;
    - 测试： 面包的可加的料有很多，而且可加的次数不受限
4. 类之间的通信： 订阅者模式 Java Observable
    > 被订阅者拥有订阅者列表，可对该列表进行添加等操作, 当自身的某些东西改变时, 触发订阅者列表中的每个的set接口改变新的值
    > 订阅者有统一的接口, 订阅者有被订阅者作为构造参数, 构造同时使用被订阅者方法加入自己。
    > 订阅者根据被订阅者set自己的方法
    - 应用：窗口部件在初始化的同时注册许多
    - 测试： 温度计，被多个显示屏所订阅
5. 要初始化的类太多,初始化太繁琐: 工厂模式
    > 超级简单！ 
    > 产品类接口，然后一些产品的实现。
    > 工厂将接口作为参数，然后声明方法，通过指定的参数，即指示创建类的名称，然后拥有对应的动作
    - 测试： 工厂创建各种各样的面包
6. 有多个功能相似（有重叠）的类： 抽象工厂模式
    > 在工厂的基础上，工厂再作为接口，每个具体的工厂用于多个多个不同的产品。
    > User类在使用时，直接可选择性地创建工厂
    - 测试：不同的面包店，提供不一样的买的东西
7. 接口太复杂： 外观模式
    > 非常简单的事情
    > 主体包含很多部分控件，封装主体的操作，每个操作对应到一组组件的动作
    - 应用：应用总窗口的创建操作
    - 测试：party房间绝对房间中的一切状态
8. 方法的步骤很多，以及处理种类各异: 命令模式 Java
    > 声明中间Command接口, 对应很多的实体, execute
    > 命令方发出setCommand(), 动作然后对应的Command被触发
    > 对应的Command实体可以是操纵一些方法，也可以是操纵一些类
    - 应用: 对于窗口部件的多个触发事件
    - 测试： 餐厅服务员的例子
9. 算法的封装： 模板模式
    > 抽象类作为高层, 写好了算法的绝大部分，只留下一小部分
    > 实现方法，抽象类封装具体的算法过程，具体的一小部分由继承实现
    - 应用: Arrays.Sort()
    - 测试：不同的餐厅菜单，试图实现对应的问题
10. 方法的多样性，选其一： 策略模式
    > User类的某个组件为接口，并且该接口会对应很多具体的实现
    - 测试：比如英雄可以选择多样的武器，并发出动作，每个武器的动作不一样
11. 封装集合，不同的物理实现； 迭代器模式
    > 首先迭代器一个接口，然后每种物理的储存抽象为迭代器，扩展自迭代器接口。
    > 具体的迭代器实现传入目标类为构造参数。目标类有createIterator调用迭代的方法，创建迭代器
    > 使用时直接使用迭代器接口即可
    - 测试: 建立多个不同物理集合方式的类，然后进行遍历
12. 同等方式对待整体和个体的元素： 组合模式
    > 首先具有统一的接口
    > 对于方法，不过某些只能叶子实现，某些只能组合实现。
    > 对于组合来说，会维护一个数组，表示其拥有的元素；每个组合，一个print可以完全展示其所有元素
    > 扩展使用，组合+迭代器，如何实现的?
    > Iterator接口， CompositeIterator() 组合迭代器，本身会维护一个栈, 当new时，会push进入元素。
    > CompositeIterator()的next(),hasNext()实现有讲究； 取next时，会递归地将成分解析!!!, 当发现真正的叶子时，进行加入，并返回该元素; hasNext()的判断过程也是一个递归的过程
    > hard!!  menu createIterator(menuComponents.iterator) meanComponents为数组元素
    > NullIterator, false, null; 供叶子使用;
    - 测试： 由menu接口来做, menuComponent来共同生成，menu作为组合， menu可以添加menu, 或者menuItems, 测试遍历输出结果如何
13. 对象更易于分割为各个状态，而且更简单： 状态模式
    > 每个状态接口，不同状态进行扩展，每个状态会实现这些的方法，而且这些类中的这些方法一般会包含状态的转换
    > 对于主类，常见的操作是这些各种类实际是组成部分，当然会有一些简易的初始化步骤
    - 测试： 完全一系列主类的动作，通过主类当前的状态的输出进行查看
14. 对象的访问控制： 代理模式
    - 远程代理
        > 实际上是远程通信
        > 实现一个远程代理接口(注意返回值和参数都是可序列化对象，并抛出异常)，该接口继承自具体的Remote;
        > 实现远程代理接口的具体类（需要继承UnicastRemoteObject， 同时要求有个午餐的构造器），实际上是具体的服务。因为涉及到远程，所以这里首先注册rmi rmiregistry产生对应代理辅助对象
        > 开启服务端，服务端创建一个对象，然后使用Naming.rebind("name", new MyRemoteImpl())注册。
        > 服务端运行， 并且在存根产生目录rmiregistry运行辅助对象
        > 客户端请求 直接使用MyRemote接口，然后使用Naming.lookup("rmi://localhost" + name)得到远程对象。
        > 然后得到的这个对象即可直接使用。
        - 测试：直接输出远程对象的方法
    - 动态代理
        > 使用java自带的Proxy
        > 例子：实现一个类的访问权限控制。
        > 首先，一个类接口，一个具体类
        > 一个关于类的代理 implements InvocationHandler, 构造函数参数为类接口。
            > 根据 Proxy.newProxyInstance(classloader, interfaces(), new Handler(a))方法返回一个原类
        > 实现invoke()方法，即对可使用的方法进行过滤，对参数进行过滤；一起进行重新分配
        - 测试： 使用返回回来的原类进行测试，是否实现了过滤

> 如何能够更快速，简便地画图？
> 思考，现在打字只是为了记住一些东西，但是记录的东西意义性值得考虑


15. 复合模式之MVC
> MVC: model, view, control
view和contrl都是view的观察者, model改变后会直接告诉contrl, control做出对应逻辑的改变，或许产生view的变化
contrl是view的策略模式
view内部的组件实际上是组合模式。控制器只要与顶层组件进行交互即可
