---
title: nju-course-cplus
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 09:42:19
tags:
- nju
- course
- cplus
categories:
- [course, nju, cplus]
---
## 0 程序设计基础知识回顾
### 0.1 基本
程序=算法+数据结构

在程序中，数据类型来描述数据，流程控制语句来实现算法

数据类型规定了两个集合：
1. 值集
2. 操作集

基本数据类型：对应机器指令能直接处理的数据
构造数据类型：由基本数据类型构造出来的数据，枚举、数组、结构、联合、指针、引用

程序实体在内存中的安排
- 静态数据区用于全局变量、static存储类的局部变量及常量的内存分配。如果没有显式初始化，系统将把它们初始化为0
- 代码区用于存放程序的指令
- 栈区用于auto存储类的局部变量
- 堆区用于动态变量的内存分配

对于返回值：
- 如果是简单数据类型，通常在寄存器
- 否则，在一块临时内存空间，在调用者的栈空间，调用者把这块空间的地址传给被调用者，被调用者通过这个地址存储返回值

一般情况，不必关心栈的具体情况，进行混合语言编程，需要考虑不同语言在栈上的差别
过深的函数嵌套将造成栈空间不足。
对于参数来说，不应把大的结构按值传递给函数，不应定义很大的局部数组变量。
不要返回局部变量的地址，没有什么输出。
> 这里仿佛懂了为什么不在函数里定义变量，而一般的算法竞赛的代码都在开头定义，因为最终所处的位置不一样。
> 还有一点就是对于函数参数，最后的情况下还是进行地址传递的好。
### 循环&递归函数
> 循环，重点关注的是退出的元素，即循环判断语句中的内容。

循环对计算机问题求解中的穷举法和迭代法提供支持

分而治之： 把一个问题分解为若干个子问题，而每个子问题的性质与原问题相同，只是在规模上比原问题要小。每个子问题的求解过程可以采用与原问题相同的方式来进行。

递归函数的关键：
递归条件：何时进行递归调用，它描述了问题求解的一般情况，包括：分解和综合过程
结束条件：何时不需递归调用，它描述了问题求解的特殊情况或基本情况

> 递归函数中定义的局部变量在运行中分布在栈区中，而非静态数据区，因此此时临时变量将不再有效。所以务必注意在设计递归函数时的变量的要求是否符合实际的要求。
> 循环是在同一组变量上进行重复操作；递归则是在不同的变量组上进行重复操作
### 指针和引用

> 指针再理解，尽管数据结构是链表，其在底层的存储方式不过是一个一个位置块而已。而指针指向它，不过是指向这些块，并能通过这些块，不断继续能访问到下面的元素。
但是，一点有意思的是，指针就像路标，指示该点的位置。而且用指针可以改变链表后面的组织方式。但指针获得后面元素的指针，对元素之间进行一顿猛操作后。前面的指针依然生效，此时返回前面的指针，就是返回一种新的位置。

指针只是一个位置的地址，可以在程序中间接来访问，通过p可以访问实参意外的数据，变量的地址； 初始化后，仍可指向其它变量
引用，变量的名字，只能直接访问实参的数据，初始化后，不能再指向其它变量。  &=const *.

&最好用，指向的变量不可改变，但可以在函数中改变其值。
> 引用类型变量
 int x=0;
 int &y=x; //y是引用类型变量，x的别名
 y=1;
 cout<<x; // x==1
 不要返回局部变量的引用，这样返回值可能会被修改。

const int & 不可不改变其值

const int *:  *p=1 X
int * const p: p=&x X

const三种用法
1. 放在开头，修饰内容，内容不可Ian
const int a=5;
const int *p = 8;
2. 放在*后面，修饰指针，指针不可变
int a = 8;
int* const p = &a;
*p = 9; // 正确
int  b = 7;
p = &b; // 错误
### 序列数据的表示
#### 1. 静态表示
int a[N];  // N为一个常量或常量表达式
好处：能够快速访问序列元素a[i]:  a的首地址+i*sizeof(int)
#### 2. 动态表示
数据的内存空间随元素数量的变化动态分配
- 动态数组
int *p=new int[n];  //动态分配数组空间，n可以是变量
p[i] // 使用数组元素，等价于*(p+i)
int *q=new int[n+m] //扩大空间
...// 元素从p到q的转移
delete []p; // 删除原来的空间
p=q;  //p指向新的空间
p[j]
##### **链表**
为每个元素动态分配内存空间，各元素的内存空间不必联系。

为了能把离散的元素空间“串”起来
好处：空间补充容易，增加、删除元素不影响其它元素
strut Node{
    int content;
    Node *next;
};
Node *head=NULL;

这里的链表头结点也有值. 所以访问时，头结点从第一个元素开始思考。
###### 访问链表元素
> 输入是链表的头结点，目的是返回元素的值

-  访问第i个元素(i=0,1,2,...)
```c++
Node *p=head;
for(int j=0;j<i && p!=NULL;j++){
    p=p->next;
}
if(p!=NULL)  *p  //访问第i个元素


设计数单位为i=4，若从0开始。值得注意的是这里
Node *head;
head=L;
while(p!=NULL & i) {
    p=p->next;
    i--;
}
```
- 访问指定元素a
```
Node *p=head;
while(p!=NULL && p->content!=a) p=p->next;
if(p!=NULL) *p //访问元素a
```

###### 在单链表中增加元素
> 传入旧的链表，目的是返回新的链表。而新的链表由头结点返回标志即可。

- 分配新元素的空间
Node *p=new Node;
- 存储元素本身的内容
p->content=..
- 找到前一个元素的位置（设由q指向它）
    - 按序号找:
    - 按内容找
- 把新元素q插入
p->next=q->next
q->next=p;
- 特殊情况的处理！
在表头增加元素q
q->next=head->next
head->next=q;  // 错误，这里把head当做空了
###### 在单链表中删除元素
- 找到前一个元素的位置（由q指向它），要删除p，则 p=q->next
  > 删除元素：
    q->next=p->next;
    delete p;
- 特殊情况的处理！
    - 要删除的元素不存在
    > 目的达到了，但关键就是是否需要进行报告所删除的元素不存在。
    > 此时遍历到最后一个节点的next节点，p==NULL
    - 删除第一个元素
    > Node *p=head;
    > if(n==0) {
    >   return head->next; //
    > }

> ? 如何结合数组与链表的优点？
STL, vector,  可以动态开辟空间，还可以随机访问。 ？

### 编译预处理命令
编译预处理命令不是C++程序所要完成的功能，而是用于对编译过程给出指导，其功能有编译预处理系统在编译时候来完成。
编译预处理命令主要有：
 
#### \#include 文件包含命令
<文件名> 在系统指定目录下寻找文件
"文件名" 现在包含改文件所在目录下寻找指定文件，再找系统文件
> 但是这里找的是工程目录？还是文件目录？

为多模块结构提供了支持
file1.h  // 进行全局变量、函数的声明
file1.cpp // 进行全局变量、函数的定义

file2.h
file2.cpp

int main(){
    double r; // 局部变量的定义
}

> 如果file1.h和file2.h发生冲突怎么办

#### \#define 宏定义命令
宏定义常用来定义变量和实现类似函数的功能：
> #define <宏名>(<参数表>) <文字串>
如： #define max(a,b) ((a)>(b) ? (a):(b))

优点：效率更高
缺点：需要加上很多的括号，否则会出问题；有时会重复计算；替换时不进行参数类型检查和转换；不利于调试

#### 条件编译命令
> 理解，一种感觉就是编写代码过程中，即实际的代码分布为多个文件，而怎么样把整个文件一起组织呢?
> 由小往大看，分为局部变量和全局变量。全局变量应该是在运行过程中堆栈中的静态数据区的。所以，这里一方面希望不能冲突
> file1.h, file2.h冲突怎么办。 用条件编译设置指示变量来表示将编译哪些内容和不编译哪些内容。

```
<代码1> 必须编译的代码
#define ABC
<代码2> 必须编译的代码
#ifdef ABC
<代码2> 如果宏名ABC有定义则编译之
#else
<代码3> //如果宏名ABC没有定义，编译之 
#endif
<代码4> //必须编译的代码
```
> 注意可以嵌入到代码中执行
> 宏可以在代码中定义，也可在编译环境中定义

```
#if <常量表达式1> / #ifdef <宏名> / #ifndef <宏名>
	<程序段1>
#elif <常量表达式2>
	<程序段2>
......
#elif <常量表达式n>
	<程序段n>
[#else
	<程序段n+1>]
#endif

```
作用：
> 避免包含头文件带来的重复定义或声明
> 基于多环境的程序编制 

```
重复包含下面的头文件不会引起多次编译
//module1.h
#ifndef MODULE1
#define MODULE1
......  //module1中的程序实体的声明或定义
#endif


编译到不同的平台
#ifdef UNIX
	......  //适合于UNIX环境的代码
#elif WINDOWS
	......  //适合于WINDOWS环境的代码
#else
	......  //适合于其它环境的代码
#endif
......  //适合于各种环境的公共代码

在开发阶段加入的调试信息：
#ifdef DEBUG
......  //调试信息，主要由输出操作构成 
#endif

```
