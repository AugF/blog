---
title: nju-course-cplus-lecture3-summary
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 09:50:15
tags:
- nju
- course
- cplus
categories:
- [course, nju, cplus]
---

## 操作符重载

首先，不能考虑传统方法，即add，为什么？因为从某种意义上来讲极其不实用。

所以考虑重载操作符, 下列不能重载
.  标志作用域的
sizeof() 计算内存空间的
?:  双判断的
:: 类的标志符

### 一般地
> 全局友元函数和成员函数两种方式。
对比来说，也就是成员函数，默认前面有类., 这其实是作为函数的默认参数this的，即const Complex&

那么就有一下几种操作符重载的例子，这里就只给出成员函数类型的
返回值、参数
- 双目
Complex opreator # (const Complex &c)
- 单目
Complex opreator *();
++i;
Complex &opreator ++();
> 前置++,返回运算后的结果。
i++;
Complex opreator ++(int);//注意这里直接是int，没有变量名，只是为了区分。
> 后置++，返回当前，实际+1；

****
特别说明，
返回值的确定，当需要返回的是一个值得改变的值是用这个。
参数的确定
****

### 特殊地
=
> 区分两种不同的含义，初始化时调用拷贝构造函数；赋值时重载函数、
> 都要注意默认的指针直接复制的问题

[]
>很简单，类似于单目运算

new
> 分配空间+调用构造函数
> 只能用静态成员来书写，static可以不用写
> void *operator new(size_t size) {
    void *p=malloc(size); // 调用系统堆空间分配操作
    memset(p,0,size); //把系统申请到的堆空间初始化为全0
    return p;
}
返回类型必须为void *
参数size表示对象所需空间的大小，其类型为size_t（unsigned int）
> 可以选择带其他参数，此时就可以在非堆区分配空间
> p = new (buf局部变量) A(size);


delete
>

>从某种意义上说，new和delete可以提高效率。因为delete归还不是归还到堆区，而是归还原本new申请的空间. 进行空间管理

()
> int opreator() (int x){return x+value;}  A a(3); cout<<a(10);
> 此时()将类对象作为了函数。有冒险用啊？
> 比如新建一个随机数对象，初始化种子后random(1)，后面每需要一个随机数random()直接产生，很快！
> ?, 这里跟函数对象有什么关系？这里是把类对象通过重载()作为函数使用

而函数对象，就是lambda表达式搞的是一大堆符号，然后后面跟一些参数。而也可以直接把它作为参数传递。

// 功能：求上下限为a,b的积分，步长假设为0.01
// 函数定义
double integrate(double (*f)(double),double a,double b){
    double sum=0;
    for(double i=a; i<=b; i+=0.01){
        sum+=f(i);
    }
    return sum;
}

// 使用：这里传入的函数对象是lambda表达式
integrate([](double x)->double { return x*x; },0,1);
> 想想这真的可以做很多东西。

->
双目，第一个为指向类或结构的指针，第二个为第一个的成员
> 例子：获取在程序执行的某个时刻获得某个对象被访问的次数
> 注意，凡是成员对象，还有成员函数被访问都算，即暴露给外界可访问的东西。
对于成员函数很容易想到可以每个里面加上cout++;但是对于数据成员不好操作。
此时即智能指针
> 想法即是在A类外部在套了个B类，B将A作为了成员，当接到访问时， B->()->f(), 第二个才访问到A的内容， B->()。 为了完全模拟还要重载其他操作符，如*,[],... 太麻烦了！！
对于歧义问题即+这种操作符，一般地会进行隐式转化，但当有一方为类就很难，显式解决。

- lambda表达式

> C++11给你规定了一堆东西，你可以拿去玩。其实也就是lambda函数那一章，其实后面还可以再加lambda表达式。最后再传递参数。

所以就允许你用函数作为参数，其实这就很容易了。突然想起了scala.
而且lambda表达式还允许你加入局部变量之类的东西。

- 继承

提出就是为了最大程度的软件复用。
日常有多种行为，就是很小的改动的那种。
比如事务按层次来分类，对概念进行组合，软件进行增量开发等等

访问控制：自己，公开，继承。

继承破坏了封装性。
耦合性是事务之间的关联程度。

继承方式，过滤器

多态性：
子类又是父类；从某种意义上说，很强大。父类指针就可以随便用。

但又带来了问题了，可以随便用。但是肯定会指向自己，所以引进虚函数。允许指向未来更好的实现。
> 高层代码完全不用修改。相比用union实现的。
于是有了纯虚函数，这就形成了真正意义上的抽象。

然后，还有聚集的方式。

总结：C++很好地用类进行数据的封装，保证了元素的私密性。
然后为了给外界提供一定的界限。
将数据的访问方式进行了分类。
对于获取信息的，外界全局函数就可以采用。const关键字很妙！
还有设置信息。

类作为类型。将不变的抽象给static元素。

然后，多态性。函数名，参数名。 再加上运算符号。

一对一并不完全符合世界的表述所以增加了多继承的方式。

然后再对类型的统一，最终就变为了泛型设计。