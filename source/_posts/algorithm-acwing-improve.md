---
title: algorithm acwing improve class
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-16 14:57:57
tags:
- algorithm
- acwing
- improve
categories:
- [algorithm, acwing, improve]
---

## 1. 概览

1. 算法学习分为这几类：
    - level 1 语法课, 直接题库搜索"语法课"即可进行练习
        > https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&search_content=%E8%AF%AD%E6%B3%95%E9%A2%98
    - level 2 算法基础课
    - level 3 算法提高课 算法的应用
        - 题目--> 模型 ---> 相似的题目(因为整理的人太少，所以这里暂时以题目为主) 题谱

2. 算法题考查两部分的内容：
    1. 思维
    2. 写代码的熟练度

3. 非常好的网站: 衡阳七中
    > 看延迟，直接看时间就可以了

## 2. DP

### 2.1 数字三角形

1. basic 
    - 采花生问题
        > 从集合角度来考虑问题, 一个集合就代替了暴搜中的一个元素
        - 状态表示 f[i, j]
            - 集合： 所有从(1, 1)走到(i, j)的路线
            - 属性： Max/Min/数量： 集合中所有集合的每个元素的最大值；
                > 于是f(n, m)就是目标值;  计算该值实际上就是寻找一个拓扑排序
        - 状态计算： 集合划分  分而治之
            > 依据最后一步来划分
            - 划分依据
                - 不重复（最值无所谓，数量必须要）
                - 不漏（所有的都必须考虑）
                > 本题图的连通性
    - 最低通行费： 最大值往往不需要初始化，最小值需要进行考虑

2. improve
    - 方格取数：难点在于如何考虑走两次
        - 走两次： 同时走
            > f[i1, j1, i2, j2]表示所有从(1,1), (1,1)分别走向(i1,j1),(i2,j2)的路径的最大值。 
            - 如何处理“同一个格子不能被重复选择”
                > 只有在i1+j1=i2+j2时，两条路径的格子才可能重合；一开始考虑使用f[i1, j1, i2, j2], 但是发现可以少一维的变量!!!
                > f[k, i1, i2]表示所有从(1,1), (1,1)分别走到(i1, k-i1), (i2, k-i2)的路径的最大值， k表示两条路线当前走到的格子的横纵坐标之和
            - 状态计算： 集合划分=下+下， 下+右， 
                > (1,1)-> (i1-1, j1), (i2-1,j2) -> (i1, j1), (i2, j2)
                - 集合划分
                    > 将(1,1)到(k, i1, i2)的路分为两种
                    > (1,1)--> (i1-1, j1) -> (i1, j1)
                    > (1,1)--> (i2-1, j2) -> (i2, j2)
                    > f(k-1, i1-1, i2-1), 根据(i1,j1),(i2,j2)是否是同一个格子，重合 w(i1, j1); 不重合， w(i1, j1)+w(i2, j2)
                    - 1： 下， 2： 下
                    - 1： 下， 2： 右
                    - 1： 右， 2： 下
                    - 1： 右， 2:  右

### 2.2 最长上升子序列问题

LIS(longest increase subsequence)
    1017 怪盗基德
        1014 登山，482 合唱队形
    1012 友好城市
    1016 最大上升子序列
    1010(+贪心) 拦截导弹
        187(+dfs) 导弹防御系统
    272(LCS) 最长公共上升子序列

#### 2.2.1 basic
895: 最长上升子序列问题
- 状态表示f[i]
    - 集合： 所有以a[i]结尾的严格单调上升子序列
    - 属性： Max
- 状态计算
    - 划分依据：最后一个不同的点。
        > 如果不能在前面很快判断，那么最基本的想法就是枚举来做，空
        
> LLS实际上可以从n^2转化为nlogn, 实际与后面的一步的转化。 优化？


272： 最长上升公共子序列
f[i,j]
- 集合： 所有由第一个序列的前i个字母，第二个序列的前j个字母, 且以b[j]结尾的构成的公共子序列，Max
    > 注意这里要加条件
- 状态计算： 
    1. 所有包含a[i]的公共上升子序列 a[i]==b[j]
        > 按照倒数第2类划分， 序列倒数第1个数时null, b[1], b[2], .., b[j-1]
        > 进行枚举  f[i,k] + 1 因为b[j]大于，所以实际上就是
    2. 所有不包含a[i]的公共上升子序列 f[i-1, j]

## 3. 背包问题： 背包九讲

01背包： 体积vi, 价值wi, 求各种放法，使得背包的总价值最大
### 3.1 basic
- 01背包
    - 完全背包
        - 多重背包I
            - 多重背包问题II + 二进制
            - 多重背包问题III + 单调队列（滑动窗口求最值）
        - 混合背包
    - 分组背包
        - 有依赖背包 + 树形DP
    - 二维费用的背包问题
    - 求具体方案
    - 求方案数


简单回顾


线性DP
序列DP: 包含选出来的一些数，相邻的数之间有一些关系

背包问题: 序列问题， 组合问题DP， 不考虑相邻元素之间的关系，考虑全局

01背包问题：每个物品选择或者不选
f[i,j]所有只从前i个物品中选，且总体积不超过j的选法的集合
划分：
1. 选择第i个物品的所有方案 f[i-1,j-v_i] + w_i 
2. 不选择第i个物品的方案 f[i-1,j]

完全背包问题： 每个物品选0，1，2，.. 个
f[i,j]所有 只从前i个物品中选择，且总体积不超过j的选法
f[i,j] = max(f[i-1,j], f[i,j-v]+w)
一般当空间优化成1维后，只有完全背包问题的体积是从小到大循环的
for 物品
    for 体积
        for 决策

多重背包问题： 每个物品选0，..., si个

规律：当空间优化到1维之后，只有完全背包问题的体积是从小到大循环的。
完全背包问题：某个物品的个数可以选任意个
> f[i, j] = max(f[i - 1, j], f[i, j-v[i]]) ! 只有这种情况是从小到大循环的。

多重背包问题：某个物品的个数给定
> 实际上，可以看作滑动窗口，这里对应的代码 todo
> 实际上，解法1： f[i,j]使用二维，直接枚举； f[j]使用一维，使用二进制优化转化为01背包问题。

分组背包问题： 每组中选择一个物品
> f[i,j] 这里的i的含义为从前i组进行选择

面试算法题，设计题

> 万能头文件 #include<bits/stdc++.h>
> 需要注意的就是这样做会导入很多文件，等于说会耗时

### 3.2 further

- 01背包
   - 采药
   - 装箱问题
   - 小精灵（阅读理解）
   - 数字组合（方案数）
   - 开心的金明
   - 能量石（+贪心）
- 完全背包
    - 买书（方案数）
    - 货币系统（方案数）
        - 货币系统（贪心）
    - 二维费用
        - 潜水员
- 多重背包
    - 庆功会
- 分组背包
    - 机器分配

思维过程，编程能力


背包问题
1. 货币系统 1021
2. 货币系统 532
3. 混合背包问题
4. 有依赖的背包问题
5. 背包问题求方案数
6. 能量石 kickstart

三种背包问题的状态表示都是一样的

动态规划
集合全部都是只从前i件物品中选，且总体积不超过j的选法的， 价值的最大值

1. 状态计算
- 01背包： f[i,j] = max(f[i-1,j], f[i-1, j-v]+w)
- 完全背包： f[i,j] = max(f[i-1,j], f[i,j-v] + w)
- 多重背包： 
f[i,j] = max(f[i-1,j], f[i-1, j-v[i]] + w[i], f[i-1,j-2v[i]]+2w[i],... ,f[i-1,j-sv[i]]+s*w[i])

不需要考虑前i件物品，只需要从第i件物品类型来分析。 

k个数进行划分，如果没有依赖关系的话，有2^k种选择。如果有的话，会大大减少依赖关系。所以直接按m来划分。

把每个子树看作是一个物品组

## 备注

链表可以直接用结构体和指针来做，实际上都可以用数组来进行模拟。
> 为什么要用数组，效率高！
> 用struct Node{int val;  Node *next;} 每次都要new一个新节点，效率非常低 

分类
1. 单链表
    - 邻接表： 用来存储图和树
2. 双链表： 用来优化某些题

3. 怎么预留，把动态规划的操作留到最后一步去，看来还是dfs最牛！

## 最多 vs 恰好 vs 至少

1. 体积最多是j,Max： 全部为0， V>=0
2. 体积恰好是j, Min: f[0]=0, f[i]=+inf  V>=0
3. 体积至少是j, Min: f[0]=0, f[i]=+inf  f[j][k]=min(f[j][k],f[max(0,j-v1)][max(0,k-v2)]+w);
> 初始化为+inf或者-inf, 自己上是为了不使用它的值 
> https://www.acwing.com/activity/content/code/update/133054/
> 潜水员问题，记得多看几遍

怎么写快速判断-1，~i，取反后即全为0

有依赖的背包问题
树形DP

## 状态机模型

多种状态，状态其实是一系列有序的事件。

状态机描述的是一个过程？
> 买入到买出

背包是一个结果

另类状态表示
- 状态机
- 状态DP

以前状态计算的时候只有一个状态，现在相当于


状态机的想法是完全转换为当前步依赖于前一步，然后讲前一步划分为各个状态，进而清晰的表示

状态DP是当前很难用维度表示，所以将状态压缩为数字进行表示

注意状态机入口也是一个很重要的部分。表明允许从哪里接入和从哪里结束

一维一般不用考虑至少，恰好，至多之类的东西

### 题目概览
1. 大盗阿福
    > 一个序列，序列中的两个数不能连续选择
2. 股票买卖IV
    > 股票某天买入，某天卖出； 交易不能重合；问怎么交易最好
3. 股票买卖V
    > 卖出后有一个冷冻期
4. 设计密码： kmp + 状态DP
    > 在一维上跳动
    - kmp: 匹配的模板串，前缀与后缀相等所以可以移动位置
        1. 约定从1开始
        2. ne[i]=j: p[1,..j]=p[i-j+1,i]; 
        3. 基准： i-1与j匹配， i与j+1不匹配， 所以每轮比较的是i与j+1
            - 失配：
                失配时最少移动距离，新的已匹配下标就是ne[j]; 然后再看下一个点i与j+1是否匹配，如果不匹配，继续失配递归处理
            - 匹配
                - i==n: 输出结果
        4. 如何找ne[]:
            > 其实就是自己串跟自己串比较；然后ne[1]=0, 递归生成；其实就是模板匹配的过程，不断地比较，处理适配，当将p[i]与p[j+1]匹配时，实际是就是p[1,..,j] == p[i-j+1,...,i], 即直接赋值ne[i]=j;
5. 修复DNA： AC自动机=trie+kmp和状态DP的结合
    > 在二维上跳动

## 状态压缩DP
### 1. 棋盘式（基于连通性）
对于棋盘，当前这行怎么枚举，只需要考虑上行的状态即可

1. 骑士
    > 井字形方格约束, 记i行状态为a，i-1行状态为b
    - a&b==0: a,b不能有相邻
    - (a|b) 不能有相邻
2. 玉米田
    > 某些地不能种
3. 炮兵布阵
    > 相邻的多个行或者列不能种
4. 愤怒的小鸟
    > 关键分析两个点确定抛物线，然后查看每个抛物线能覆盖哪些顶点。DP的想法实际上是从0到最终覆盖，对非0的点进行选择，来覆盖对应的选择，即状态划分过程。

## 区间DP
感觉就是一堆数，可以按某种要求进行合并。合并在一起是具有代价的。目标就是问怎样合并能够使得总代价最小


1. 环形DP
2. 记录方案数
3. 高精度
4. 二维区间DP

- 石子合并
    > 一个线段上的多个数最终合并为一个数。然后可以按区间合并，看合并的代价。
    - 集合： f[i,j]: 所有从i到j和并的最小值。
    - 状态计算： 按照最后一步进行划分，就是两个点的分界点
    > !!! 分界点,  min(f[l,k]+f[k+1,r]+s[l,r])

环形石子合并
加分二叉树：区间DP的方案数
棋盘分割：二维DP
凸多边形： 高精度
能量项链

## 树形DP

DP问题的实质是用一个点表示一类情况
树形DP的本质是用当前节点表示所包含子树的所有情况

1. 树的直径
    > 对于无权边而言
    - 任取一点作为起点，找到距离该点最远的一个点u, DFS
    - 再找到距离u最远的一个点 DFS, BFS(DFS费空间)
    - 那么u和v之间的路径就是一条直径
        > 证明: 这个过程还是很有意思的。利用的树一定是连通的，所以直接设置a->u的论据，和一条最短直径的相互比较即可退出矛盾
    - DP 一般做法

2. 树的中心：求最远距离的最小值。有上下两个地方的衡量，使用数组保存结果来解决问题

3. 数字转换：使用筛法预处理出因素和，建模为求树上的某条最远路径
4. 二叉苹果树： 有依赖的背包问题： 有依赖？选背包时选择某一件物品就必须选择另一件物品
5. 战略游戏： 
    > vs 没有上司的舞会： 每条边最多选一个点，求最大权值
    > 战略游戏： 每条边至少选一个点，求最小权值
6. 皇宫守卫

## 数位DP
DP问题的技巧: 基本上问的都是区间问题 
1. 技巧1：f[N]: 1~N
    > [X, Y]: f[Y] - f[X - 1] 前缀和
2. 技巧2：尽量用树的方式考虑

本质上其实都还是排列组合数，但是不大好用排列组合来求
方案，分情况讨论

1. 度的数量： 就像摘苹果一样，每一个苹果都要小心翼翼地摘，不要漏了，也不要重了

2. 不降数
## 单调队列/单调栈/其它数据结构优化的DP

解决问题有限，求滑动窗口中的值。
首尾端点不需要固定，只需要都保持严格递增就可以

把队列中所有冗余的元素去掉，会发现队列有单调的性质
其实，如果是最小值，往往对应的是单调上升序列

1. 朴素DP原理：正确性
2. DP优化，代码等价变形，观察代码

## 斜率优化DP

### 2. 集合     

### 对比
状态压缩DP是将所有的状态用一个二进制来表示了

## 3. 搜素
### 3.1 BFS
应用型算法，题目变化很多，题型很多

最核心的问题：
1. “求最小”
2. 基于迭代，不会爆栈

1. 迷宫：最短距离
    > 可以从地图的一个点到达另一个点

2. 八数码：最小步数
    > 把整个地图看作是一个状态，实际上求的就是从一个状态到达另一个状态的

#### 3.1.1 Flodd Fill
洪水覆盖

水可以向周围覆盖。覆盖过的格子又可以覆盖。

不断加入新的格子，直到不能覆盖。

可以在线性时间复杂度内，找到某个点所在的连通块。
100个格子会导致爆栈

在生产空间，栈内存可以设定到内存一样大的
默认1M.  1M/每一层的空间=最大层

算法：思维+代码

常见的连通有两种：
1. 四连通： 只要有公共边就叫连通  人们常认为的模型
2. 八连通： 只要有公共点就叫连通  八连通

#### 3.1.2 最短路模型

这里实际上是所有边权都一样的最短路模型

单源最短路

在线性时间内，可以得到所有点到某点的最短路

如何输出路径？

对于路径的数组，其实可以pre数组。

因为BFS本身就是按层搜，所以不用其他算法一样存储距离
很多时候从哪个点开始，其实只是为了最后处理结果方便一点而已

!!! BFS实际上就是每条边权为1的最短路模型

为什么可以？
其实来源于迪杰斯特拉最短路算法，它本身是维护一个优先队列，取队列中的最大值和最小值。而当边的权重都是1的时候。BFS所维护的队列就是一个单调增的队列，也就是说队头最小值，队尾最大值

BFS队列中的顺序实际上就是到起点的距离递增的顺序来扩展的

队列：
1. 两段性：最多有两段
2. 单调性： 初始， 假设

证明队首出队的元素一定是最小值
> 反证法，如果出队的元素不是最小值，那么一定是由队列中后面的元素，转了一圈后，然后连接到该点。而由队列的单调性，后面所描述的距离一定是大于之前的距离的，所以矛盾。

每个元素只会入队一次，入队后值就确定，等于说它的值只会被更新一次。

#### 3.1.3 多源BFS
实际上就是把所有多源路径距离置为0，添加到队列中即可

#### 3.1.4 最小步数模型
第二类的最短路的模型

1. 如何存状态？ hash法，map(c++11)
    > 康拓展开, map, unordered_map

思路： 将整个棋盘压缩成的状态。每次按搜索策略搜索，每个走过的状态标记下已经走过。直到到达最终状态为止。

#### 3.1.5 双端队列广搜

专门用来处理边权为0或1的图。

怎么理解？
将边权为0的放到队列开头，边权为1的放到队列结尾。
仍然满足单调性、两段性

这里因为有边权为0的边的存在，一个点可能会更新多次
#### 3.1.6 双向广搜

对于第二类算法，其实它总共有的状态数为格子的阶乘，太多了

宽搜，因为会存储当前层元素，所以会MLE. 如果状态太多，也会TLE.

实际上，每一层元素是呈指数上升的

双向搜素为什么有效？
其实可以通过图来观察搜素空间，是变小的

一种直观的感受
6^10,   2*6^5

一般来说，只会用到最小步数模型。

一个优化，每次选择当前队列扩展元素较小的方向来扩展
#### 3.1.7 A*

目标跟双向广搜是一样的

队列换成优先队列， 小根堆

小根堆： 
关键字：真实距离（从起点走到当前点的真实距离）+估价距离（从当前点到终点的估计距离）

选一个关键字最小的t
当终点第一次出队时 break;
for t的所有邻边:  将邻边入队, 更新距离

图中所有边权都是任何都可以，只要没有非负回路？

迪杰斯特拉算法: 所有估价距离都取0的算法

成立条件：

d(state) + g(state)
d(state) + f(state)

f(state) <= g(state)：估价函数小于真实函数
必须要有解才能用
无解的话也需要对所有状态操作一遍，而且由于相比于BFS使用的队列是nlogn, 所以更耗时

如何证明成立？
假设出队的元素，最小的为dist, 它不是最小的 即 dist > d最优
那么必然存在最优路径上的某个点u（起点一定在上面）, d[u]+f[u] <= d[u]+g[u]=d最优。

而队列中最优距离一定是最小的数，即d[u]+f[u]一定是最小的， dist <= d[u]+f[u] <= d最优， 矛盾

只能保证终点出队的时候，终点一定是最优的点
> 算法进阶指南写错的一点
> 其实是最优路径上的点都是最优

对于其他点，入队出队都不一定是最优距离
<!--  -->
每个点也并不是只扩展一次, 每个点入队多次  Dijkstra 
f in [0, g]

BFS: 入队的时候判重， 即不再使用  
Dijkstra: 出队的时候判重
A*: 出队后不能判重，终点出队才能判重

估计距离：
能用A*算法题目不多

spfa可能会搜索空间多
A*是为了尽可能减少搜索空间

##### 八数码

估价函数为当前点的位置与真实位置的曼哈顿距离之和

### 3.2 DFS

#### 3.2.1 DFS之连通性模型和搜索顺序
BFS: 队列
1. 连通性
2. 内部的某个部分能否走到另一个部分
3. 整个看成一个整体
4. 搜索空间减小

DFS: 代码短，但是第一次到达某个点
时间复杂度都是一样的，每个点只需要遍历一次

注意爆栈问题，输入一个数据，想一下会不会在极限情况下爆栈

手动地把递归改为非递归

注意两种模型：
一种是棋盘内部搜索。棋盘内每个点只需要搜索一次， 内部搜索
一种是整个棋盘搜索（对于这种类型时需要恢复现场的），外部搜索

外部搜索即可以处理路径数的问题，又可以处理最优化的问题

暴搜： 2^n, NP完全问题

#### 3.2.2 DFS之剪枝优化

常用的剪枝策略
1. 优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的节点
2. 排除等效冗余：不考虑顺序的情况下，尽可能使用组合
3. 可行性剪枝：搜索到一半发现不合法，提前退出
4. 最优性剪枝：无论如何当前搜索到的结果都比最优取值差，剪枝
5. 记忆化搜索(DP) *

### 3.3 迭代加深

BFS: 宽搜的空间复杂度，因为需要把每一层中的所有元素存下来，所以是指数级别的
DFS: O(n)

max_depth 逐步扩大，从0开始

设置一个max_depth, 走完一个，然后再走一个

DFS: 具体的时间复杂度估计就行了，很难具体量算

## ？ 补充

RSA密钥原理
Q*P=N
N作为公钥，P，Q作为密钥，P知道Q的密钥，分别被双方拥有。实际上是基于大整数分解非常困难的原因。
> A知道B的密钥，公钥，AB都知道，所以B就可以访问A，A就可以验证是否符合要求。


井田制
> 田字型的土地，土地由农民自己，然后向中心交税


为什么炮兵的炮弹不会被山地阻挡？
> 因为它的运动轨迹是抛物线的

- DP:
    - 数字三角形模型：
        > 当前步，简单地方格，向右走和向上走
        - 扩展：走k次如何计算？
    - 最长上升子序列模型：
        > 使用单调队列的方法构造上升子序列？？
    - 背包问题：完全背包和多重背包，形如多少个物品，每个物品有对应的属性，多个，每个属性有自己的约束，求最值和方案数
        - 可能扩展
            - 预处理，预先排序。把几个属性合在一起看
            - 多重背包问题的重叠
            - 分组背包：有多个依赖：转换为离散值，当太复杂时，过渡到树形DP*
        - 不熟练点
            - 求具体方案
            - 属性
    - 状态机模型： 状态直接考虑会依赖到上一层以上的状态，所以将上一层分为离散的状态来考虑
    - 状态压缩DP: 将上一层的状态用二进制来表示

记忆化搜索模式

```
int dp(int l, int r) {
    int& v = f[l][r];
    if (v >= 0) return v;
    // 计算过程

    return v=get();
}

return f(1, n);
```

现象-> 逻辑（写法）：应试教育

最大独立集：有很多点，很多边

不包含一个字符串, KMP
包含多个字符串，树形DP


闫式最优化问题分析法

在一个有限集合中秋最值，或者个数。
> 有可能方案是无限集，通过贪心证明，结果在有限集中
将所有情况划分到集合中，从而来查看集合与集合之间的关系


古代的烽火传递： 现在一般都用光纤等，电波等传递信号，而古代的时候是怎么传递信号的呢。用的是可见光，即烟能够向上空飘去，点表示敌人来犯。

白天用烟，晚上用火。

容错机制。
在可见范围内多放几座信号塔

物理化学是第二次工业革命的产物，信息技术才是第三四次工业革命的产物

一个行业要在前几年入，但有风险是肯定的。不能有很好的晋升机会，现在大公司都在裁员

一个经济周期往往会不断的波动，但是整个平均值是在提高的，平均值就是生产力的增长。
在不久的将来很多人就可以不工作
每天的需要是什么？吃饭、电力、暖气、WIFI、睡觉

经济周期好的时候放债具有更好的收益。债务放出来说明整个社会的钱变多了，说明社会的平均工资变多了。
债务达到一个峰值没有跟生产力匹配的时候就会产生泡沫。
经济就会下行，资本就会进入寒冬，没有人放债。
当它低于一个下行值时，又会上升


数组越界，爆栈

错误，检查for循环的终止条件是否正确

注意由于对齐原理，结构体有时间开辟的空间更大


对于BFS,DFS，其实还需要考虑的一个问题就是，这个点访问几次

奇怪的问题 queue<int> q; cout << 一大堆数

迪杰斯特拉在非负权边上做都可

define 会多两条指令