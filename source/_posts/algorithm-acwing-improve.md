---
title: algorithm acwing improve class
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-16 14:57:57
tags:
- algorithm
- acwing
- improve
categories:
- [algorithm, acwing, improve]
---

## 1. 概览

1. 算法学习分为这几类：
    - level 1 语法课, 直接题库搜索"语法课"即可进行练习
        > https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&search_content=%E8%AF%AD%E6%B3%95%E9%A2%98
    - level 2 算法基础课
    - level 3 算法提高课 算法的应用
        - 题目--> 模型 ---> 相似的题目(因为整理的人太少，所以这里暂时以题目为主) 题谱

2. 算法题考查两部分的内容：
    1. 思维
    2. 写代码的熟练度

3. 非常好的网站: 衡阳七中
    > 看延迟，直接看时间就可以了

## 2. DP

### 2.1 数字三角形

1. basic 
    - 采花生问题
        > 从集合角度来考虑问题, 一个集合就代替了暴搜中的一个元素
        - 状态表示 f[i, j]
            - 集合： 所有从(1, 1)走到(i, j)的路线
            - 属性： Max/Min/数量： 集合中所有集合的每个元素的最大值；
                > 于是f(n, m)就是目标值;  计算该值实际上就是寻找一个拓扑排序
        - 状态计算： 集合划分  分而治之
            > 依据最后一步来划分
            - 划分依据
                - 不重复（最值无所谓，数量必须要）
                - 不漏（所有的都必须考虑）
                > 本题图的连通性
    - 最低通行费： 最大值往往不需要初始化，最小值需要进行考虑

2. improve
    - 方格取数：难点在于如何考虑走两次
        - 走两次： 同时走
            > f[i1, j1, i2, j2]表示所有从(1,1), (1,1)分别走向(i1,j1),(i2,j2)的路径的最大值。 
            - 如何处理“同一个格子不能被重复选择”
                > 只有在i1+j1=i2+j2时，两条路径的格子才可能重合；一开始考虑使用f[i1, j1, i2, j2], 但是发现可以少一维的变量!!!
                > f[k, i1, i2]表示所有从(1,1), (1,1)分别走到(i1, k-i1), (i2, k-i2)的路径的最大值， k表示两条路线当前走到的格子的横纵坐标之和
            - 状态计算： 集合划分=下+下， 下+右， 
                > (1,1)-> (i1-1, j1), (i2-1,j2) -> (i1, j1), (i2, j2)
                - 集合划分
                    > 将(1,1)到(k, i1, i2)的路分为两种
                    > (1,1)--> (i1-1, j1) -> (i1, j1)
                    > (1,1)--> (i2-1, j2) -> (i2, j2)
                    > f(k-1, i1-1, i2-1), 根据(i1,j1),(i2,j2)是否是同一个格子，重合 w(i1, j1); 不重合， w(i1, j1)+w(i2, j2)
                    - 1： 下， 2： 下
                    - 1： 下， 2： 右
                    - 1： 右， 2： 下
                    - 1： 右， 2:  右

### 2.2 最长上升子序列问题

LIS(longest increase subsequence)
    1017 怪盗基德
        1014 登山，482 合唱队形
    1012 友好城市
    1016 最大上升子序列
    1010(+贪心) 拦截导弹
        187(+dfs) 导弹防御系统
    272(LCS) 最长公共上升子序列

#### 2.2.1 basic
895: 最长上升子序列问题
- 状态表示f[i]
    - 集合： 所有以a[i]结尾的严格单调上升子序列
    - 属性： Max
- 状态计算
    - 划分依据：最后一个不同的点。
        > 如果不能在前面很快判断，那么最基本的想法就是枚举来做，空
        
> LLS实际上可以从n^2转化为nlogn, 实际与后面的一步的转化。 优化？


272： 最长上升公共子序列
f[i,j]
- 集合： 所有由第一个序列的前i个字母，第二个序列的前j个字母, 且以b[j]结尾的构成的公共子序列，Max
    > 注意这里要加条件
- 状态计算： 
    1. 所有包含a[i]的公共上升子序列 a[i]==b[j]
        > 按照倒数第2类划分， 序列倒数第1个数时null, b[1], b[2], .., b[j-1]
        > 进行枚举  f[i,k] + 1 因为b[j]大于，所以实际上就是
    2. 所有不包含a[i]的公共上升子序列 f[i-1, j]

## 3. 背包问题： 背包九讲

01背包： 体积vi, 价值wi, 求各种放法，使得背包的总价值最大
### 3.1 basic
01背包
    完全背包
        多重背包I
            多重背包问题II + 二进制
            多重背包问题III + 单调队列（滑动窗口求最值）
        混合背包
    分组背包
        有依赖背包 + 树形DP
    二维费用的背包问题
    求具体方案
    求方案数


简单回顾


线性DP
序列DP: 包含选出来的一些数，相邻的数之间有一些关系

背包问题: 序列问题， 组合问题DP， 不考虑相邻元素之间的关系，考虑全局

01背包问题：每个物品选择或者不选
f[i,j]所有只从前i个物品中选，且总体积不超过j的选法的集合
划分：
1. 选择第i个物品的所有方案 f[i-1,j-v_i] + w_i 
2. 不选择第i个物品的方案 f[i-1,j]

完全背包问题： 每个物品选0，1，2，.. 个
f[i,j]所有 只从前i个物品中选择，且总体积不超过j的选法
f[i,j] = max(f[i-1,j], f[i,j-v]+w)
一般当空间优化成1维后，只有完全背包问题的体积是从小到大循环的
for 物品
    for 体积
        for 决策

多重背包问题： 每个物品选0，..., si个

规律：当空间优化到1维之后，只有完全背包问题的体积是从小到大循环的。
完全背包问题：某个物品的个数可以选任意个
> f[i, j] = max(f[i - 1, j], f[i, j-v[i]]) ! 只有这种情况是从小到大循环的。

多重背包问题：某个物品的个数给定
> 实际上，可以看作滑动窗口，这里对应的代码 todo
> 实际上，解法1： f[i,j]使用二维，直接枚举； f[j]使用一维，使用二进制优化转化为01背包问题。

分组背包问题： 每组中选择一个物品
> f[i,j] 这里的i的含义为从前i组进行选择

面试算法题，设计题

> 万能头文件 #include<bits/stdc++.h>
> 需要注意的就是这样做会导入很多文件，等于说会耗时

### 3.2 further

- 01背包
   - 采药
   - 装箱问题
   - 小精灵（阅读理解）
   - 数字组合（方案数）
   - 开心的金明
   - 能量石（+贪心）
- 完全背包
    - 买书（方案数）
    - 货币系统（方案数）
        - 货币系统（贪心）
    - 二维费用
        - 潜水员
- 多重背包
    - 庆功会
- 分组背包
    - 机器分配

思维过程，编程能力