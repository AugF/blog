---
title: algorithm acwing improve class
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-16 14:57:57
tags:
- algorithm
- acwing
- improve
categories:
- [algorithm, acwing, improve]
---

## 1. 概览

1. 算法学习分为这几类：
    - level 1 语法课, 直接题库搜索"语法课"即可进行练习
        > https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=msUJJ5LtxRvIldBlsslvchYSw8Grn8UdIM32F2WtpNs1WitNTjsvLznTVFof8cW2&search_content=%E8%AF%AD%E6%B3%95%E9%A2%98
    - level 2 算法基础课
    - level 3 算法提高课 算法的应用
        - 题目--> 模型 ---> 相似的题目(因为整理的人太少，所以这里暂时以题目为主) 题谱

2. 算法题考查两部分的内容：
    1. 思维
    2. 写代码的熟练度

3. 非常好的网站: 衡阳七中
    > 看延迟，直接看时间就可以了

## 2. DP

### 2.1 数字三角形

1. basic 
    - 采花生问题
        > 从集合角度来考虑问题, 一个集合就代替了暴搜中的一个元素
        - 状态表示 f[i, j]
            - 集合： 所有从(1, 1)走到(i, j)的路线
            - 属性： Max/Min/数量： 集合中所有集合的每个元素的最大值；
                > 于是f(n, m)就是目标值;  计算该值实际上就是寻找一个拓扑排序
        - 状态计算： 集合划分  分而治之
            > 依据最后一步来划分
            - 划分依据
                - 不重复（最值无所谓，数量必须要）
                - 不漏（所有的都必须考虑）
                > 本题图的连通性
    - 最低通行费： 最大值往往不需要初始化，最小值需要进行考虑

2. improve
    - 方格取数：难点在于如何考虑走两次
        - 走两次： 同时走
            > f[i1, j1, i2, j2]表示所有从(1,1), (1,1)分别走向(i1,j1),(i2,j2)的路径的最大值。 
            - 如何处理“同一个格子不能被重复选择”
                > 只有在i1+j1=i2+j2时，两条路径的格子才可能重合；一开始考虑使用f[i1, j1, i2, j2], 但是发现可以少一维的变量!!!
                > f[k, i1, i2]表示所有从(1,1), (1,1)分别走到(i1, k-i1), (i2, k-i2)的路径的最大值， k表示两条路线当前走到的格子的横纵坐标之和
            - 状态计算： 集合划分=下+下， 下+右， 
                > (1,1)-> (i1-1, j1), (i2-1,j2) -> (i1, j1), (i2, j2)
                - 集合划分
                    > 将(1,1)到(k, i1, i2)的路分为两种
                    > (1,1)--> (i1-1, j1) -> (i1, j1)
                    > (1,1)--> (i2-1, j2) -> (i2, j2)
                    > f(k-1, i1-1, i2-1), 根据(i1,j1),(i2,j2)是否是同一个格子，重合 w(i1, j1); 不重合， w(i1, j1)+w(i2, j2)
                    - 1： 下， 2： 下
                    - 1： 下， 2： 右
                    - 1： 右， 2： 下
                    - 1： 右， 2:  右

### 2.2 最长上升子序列问题

LIS(longest increase subsequence)
    1017 怪盗基德
        1014 登山，482 合唱队形
    1012 友好城市
    1016 最大上升子序列
    1010(+贪心) 拦截导弹
        187(+dfs) 导弹防御系统
    272(LCS) 最长公共上升子序列

#### 2.2.1 basic
895: 最长上升子序列问题
- 状态表示f[i]
    - 集合： 所有以a[i]结尾的严格单调上升子序列
    - 属性： Max
- 状态计算
    - 划分依据：最后一个不同的点。
        > 如果不能在前面很快判断，那么最基本的想法就是枚举来做，空
        
> LLS实际上可以从n^2转化为nlogn, 实际与后面的一步的转化。 优化？


272： 最长上升公共子序列
f[i,j]
- 集合： 所有由第一个序列的前i个字母，第二个序列的前j个字母, 且以b[j]结尾的构成的公共子序列，Max
    > 注意这里要加条件
- 状态计算： 
    1. 所有包含a[i]的公共上升子序列 a[i]==b[j]
        > 按照倒数第2类划分， 序列倒数第1个数时null, b[1], b[2], .., b[j-1]
        > 进行枚举  f[i,k] + 1 因为b[j]大于，所以实际上就是
    2. 所有不包含a[i]的公共上升子序列 f[i-1, j]

## 3. 背包问题： 背包九讲

01背包： 体积vi, 价值wi, 求各种放法，使得背包的总价值最大
### 3.1 basic
- 01背包
    - 完全背包
        - 多重背包I
            - 多重背包问题II + 二进制
            - 多重背包问题III + 单调队列（滑动窗口求最值）
        - 混合背包
    - 分组背包
        - 有依赖背包 + 树形DP
    - 二维费用的背包问题
    - 求具体方案
    - 求方案数


简单回顾


线性DP
序列DP: 包含选出来的一些数，相邻的数之间有一些关系

背包问题: 序列问题， 组合问题DP， 不考虑相邻元素之间的关系，考虑全局

01背包问题：每个物品选择或者不选
f[i,j]所有只从前i个物品中选，且总体积不超过j的选法的集合
划分：
1. 选择第i个物品的所有方案 f[i-1,j-v_i] + w_i 
2. 不选择第i个物品的方案 f[i-1,j]

完全背包问题： 每个物品选0，1，2，.. 个
f[i,j]所有 只从前i个物品中选择，且总体积不超过j的选法
f[i,j] = max(f[i-1,j], f[i,j-v]+w)
一般当空间优化成1维后，只有完全背包问题的体积是从小到大循环的
for 物品
    for 体积
        for 决策

多重背包问题： 每个物品选0，..., si个

规律：当空间优化到1维之后，只有完全背包问题的体积是从小到大循环的。
完全背包问题：某个物品的个数可以选任意个
> f[i, j] = max(f[i - 1, j], f[i, j-v[i]]) ! 只有这种情况是从小到大循环的。

多重背包问题：某个物品的个数给定
> 实际上，可以看作滑动窗口，这里对应的代码 todo
> 实际上，解法1： f[i,j]使用二维，直接枚举； f[j]使用一维，使用二进制优化转化为01背包问题。

分组背包问题： 每组中选择一个物品
> f[i,j] 这里的i的含义为从前i组进行选择

面试算法题，设计题

> 万能头文件 #include<bits/stdc++.h>
> 需要注意的就是这样做会导入很多文件，等于说会耗时

### 3.2 further

- 01背包
   - 采药
   - 装箱问题
   - 小精灵（阅读理解）
   - 数字组合（方案数）
   - 开心的金明
   - 能量石（+贪心）
- 完全背包
    - 买书（方案数）
    - 货币系统（方案数）
        - 货币系统（贪心）
    - 二维费用
        - 潜水员
- 多重背包
    - 庆功会
- 分组背包
    - 机器分配

思维过程，编程能力


背包问题
1. 货币系统 1021
2. 货币系统 532
3. 混合背包问题
4. 有依赖的背包问题
5. 背包问题求方案数
6. 能量石 kickstart

三种背包问题的状态表示都是一样的

动态规划
集合全部都是只从前i件物品中选，且总体积不超过j的选法的， 价值的最大值

1. 状态计算
- 01背包： f[i,j] = max(f[i-1,j], f[i-1, j-v]+w)
- 完全背包： f[i,j] = max(f[i-1,j], f[i,j-v] + w)
- 多重背包： 
f[i,j] = max(f[i-1,j], f[i-1, j-v[i]] + w[i], f[i-1,j-2v[i]]+2w[i],... ,f[i-1,j-sv[i]]+s*w[i])

不需要考虑前i件物品，只需要从第i件物品类型来分析。 

k个数进行划分，如果没有依赖关系的话，有2^k种选择。如果有的话，会大大减少依赖关系。所以直接按m来划分。

把每个子树看作是一个物品组

## 备注

链表可以直接用结构体和指针来做，实际上都可以用数组来进行模拟。
> 为什么要用数组，效率高！
> 用struct Node{int val;  Node *next;} 每次都要new一个新节点，效率非常低 

分类
1. 单链表
    - 邻接表： 用来存储图和树
2. 双链表： 用来优化某些题

3. 怎么预留，把动态规划的操作留到最后一步去，看来还是dfs最牛！

## 最多 vs 恰好 vs 至少

1. 体积最多是j,Max： 全部为0， V>=0
2. 体积恰好是j, Min: f[0]=0, f[i]=+inf  V>=0
3. 体积至少是j, Min: f[0]=0, f[i]=+inf  f[j][k]=min(f[j][k],f[max(0,j-v1)][max(0,k-v2)]+w);
> 初始化为+inf或者-inf, 自己上是为了不使用它的值 
> https://www.acwing.com/activity/content/code/update/133054/
> 潜水员问题，记得多看几遍

怎么写快速判断-1，~i，取反后即全为0

有依赖的背包问题
树形DP

## 状态机模型

多种状态，状态其实是一系列有序的事件。

状态机描述的是一个过程？
> 买入到买出

背包是一个结果

另类状态表示
- 状态机
- 状态DP

以前状态计算的时候只有一个状态，现在相当于


状态机的想法是完全转换为当前步依赖于前一步，然后讲前一步划分为各个状态，进而清晰的表示

状态DP是当前很难用维度表示，所以将状态压缩为数字进行表示

注意状态机入口也是一个很重要的部分。表明允许从哪里接入和从哪里结束

一维一般不用考虑至少，恰好，至多之类的东西

### 题目概览
1. 大盗阿福
    > 一个序列，序列中的两个数不能连续选择
2. 股票买卖IV
    > 股票某天买入，某天卖出； 交易不能重合；问怎么交易最好
3. 股票买卖V
    > 卖出后有一个冷冻期
4. 设计密码： kmp + 状态DP
    > 在一维上跳动
    - kmp: 匹配的模板串，前缀与后缀相等所以可以移动位置
        1. 约定从1开始
        2. ne[i]=j: p[1,..j]=p[i-j+1,i]; 
        3. 基准： i-1与j匹配， i与j+1不匹配， 所以每轮比较的是i与j+1
            - 失配：
                失配时最少移动距离，新的已匹配下标就是ne[j]; 然后再看下一个点i与j+1是否匹配，如果不匹配，继续失配递归处理
            - 匹配
                - i==n: 输出结果
        4. 如何找ne[]:
            > 其实就是自己串跟自己串比较；然后ne[1]=0, 递归生成；其实就是模板匹配的过程，不断地比较，处理适配，当将p[i]与p[j+1]匹配时，实际是就是p[1,..,j] == p[i-j+1,...,i], 即直接赋值ne[i]=j;
5. 修复DNA： AC自动机=trie+kmp和状态DP的结合
    > 在二维上跳动

## 状态压缩DP
### 1. 棋盘式（基于连通性）
对于棋盘，当前这行怎么枚举，只需要考虑上行的状态即可
### 2. 集合     

### 对比
状态压缩DP是将所有的状态用一个二进制来表示了

## 补充

RSA密钥原理
Q*P=N
N作为公钥，P，Q作为密钥，P知道Q的密钥，分别被双方拥有。实际上是基于大整数分解非常困难的原因。
> A知道B的密钥，公钥，AB都知道，所以B就可以访问A，A就可以验证是否符合要求。


井田制
> 田字型的土地，土地由农民自己，然后向中心交税


- DP:
    - 数字三角形模型：
        > 当前步，简单地方格，向右走和向上走
        - 扩展：走k次如何计算？
    - 最长上升子序列模型：
        > 使用单调队列的方法构造上升子序列？？
    - 背包问题：完全背包和多重背包，形如多少个物品，每个物品有对应的属性，多个，每个属性有自己的约束，求最值和方案数
        - 可能扩展
            - 预处理，预先排序。把几个属性合在一起看
            - 多重背包问题的重叠
            - 分组背包：有多个依赖：转换为离散值，当太复杂时，过渡到树形DP*
        - 不熟练点
            - 求具体方案
            - 属性
    - 状态机模型： 状态直接考虑会依赖到上一层以上的状态，所以将上一层分为离散的状态来考虑
    - 状态压缩DP: 将上一层的状态用二进制来表示
