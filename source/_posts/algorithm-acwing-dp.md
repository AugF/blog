---
title: algorithm acwing dp
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 12:12:04
tags:
- algorithm
- acwing
- dp
categories:
- [algorithm, acwing, basic, dp]
---

转换为背包问题
线性DP, 区间DP, 计数类DP， 数位统计DP, 状态
压缩DP, 树形DP, 记忆化搜索


1. 01背包
N, V   vi, wi
> 每件物品仅用一次

总体积一定的时候求最大价值

2. 完全背包问题 每件物品有无限个
3. 多重背包问题 每个物品有si个
优化

4. 分组背包问题 物品有n组，每组有若干个。 每组中最多选一个。


# 1 DP问题

## 1.1 基本形式
> 问题是什么？从n个物品中选，体积为V的最大价值。
所求一般为函数值。

### 1.1.1 状态表示f(i,j)

1. 集合： 考虑的是状态的哪一个集合， 所有选法的一个集合
条件
- 只从前i个物品选
- 选出来的物品总体积小于等于j
2. 属性： Max, Min, 数量

> f[n,v]即所求

#### 1.1.2 状态计算： 如何一步步地把每个状态算出来
集合划分：如何转化为更小的集合
> 划分有什么方法吗？？？ 这里是对第i个分析，然后对前面的方法进行
> 每个问题有多种理解方式，尽量往简单走

原则： 不重复（某个元素属于某一个特定集合），不漏（每个元素必须都给分配了）
> 一般情况只要满足不漏就可以，如果是对元素个数考虑则要满足不重复的原则

f(i,j): 含i 和 不含i
不含i:  i-1, j  f(i-1, j)
含i： i-1, j-wi  f(i-1,j-wi)+wi

f(i,j) = max(f(i-1,j),   f(i-1,j-vi)+wi )
发现这里i->(i-1), 所以只需要考虑i-1的状态就可以，f(0,j)=0

> f(i,j) 只用到了f(i-1,j)   j-vi<=j.
可以用滚动数组来做

f[j] =max(f[j], f[j-v[i]]+w[i]);  // 当前有可选和不可选两种情况，单背包的01问题
> 为什么对j循环，因为需要对不同的容量进行循环判断

> i-> i-1, 变小的，正序
> j-> j-v[i], 反向

#### 1.1.3 优化：对代码或计算方程做等价变形

```
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++){
            f[i][j] =f[i-1][j];
            if(j>=v[i]) f[i][j] =max(f[i][j], f[i-1][j-v[i]]+w[i]);
        }

    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--){
            f[j] =max(f[j], f[j-v[i]]+w[i]); //f[i-1][j-vi]->f[j]
        }
    
    > 正常顺序下把f[i-1][j-v[i]]变成f[j-v[i]], 有问题，因为需要保证它是i-1层循环做的事情。而对于i层，如果j递增，那么在f[j]之前， f[j-v[i]]就已经被更新了； 所以这里使用反向，可以保证用到的就是上一层更新的内容，妙！！
```

滚动数组

f(i)->f(i-1)
> 那么考虑用f(2,N)来表示，那么就只用了两维就对原始问题进行了解释。就很方便，空间容量就下降了

# 2 背包问题

## 2.0 01背包问题： 每件物品只能选一个
i,  v,  max_w
2维
f[i,j]
状态表示
- 集合： 所有只考虑了前i个物品，其总体积不大于j的所有选法的集合
- 属性：Max
状态计算
- 集合分解
看第i个物品选或不选

时间复杂度
状态数量*每个状态所耗的时间 n^2 * 1

## 2.1 完全背包问题：每件物品可以选任意个

### 1. 状态表示
集合：所有只考虑了前i个物品，且体积不大于j的所有选法
属性:Max

### 2. 状态计算
集合的划分
f[i,j]:0,1,2,...,k
> 第i个物品选多少个？k这里有体积进行限制

f[i-1,j]
曲线救国：
1. 去掉k个物品i
2. 求Max, f[i-1,j-k*v[i]]
3. 再加回来k个物品i
f[i-1,j-k*v[i]] + k*w[i].

f[i][j]=max(f[i][j], f[i-1][j-v[i]*k]+k*w[i]);

// 三重循环

### 3. 优化：
f[i,j] = Max(f[i-1,j], f[i-1,j-v]+w,f[i-1,j-2v]+2w,...)
f[i,j-v]=Max(f[i-1,j-v], f[i-1,j-2v]+w,...)

发现 f[i,v]=Max(f[i-1,j], f[i,j-v]+w);

> 为什么不用单调队列来优化？因为这里不是求滑动窗口的最大值，所以没有必要

## 2.2 多重背包问题：每件物品最多可以选k个
f[i,j]
### 2.2.1 状态表示
集合：所有只从前i个物品中选，且总体积不超过j的选法

属性：最大值

### 2.2.2 状态计算
集合划分
> 第i个物品最多选多少个
f[i,j] = max(f[i-1,j-kv]+kw)  k=0,1,2,...,s[i]

### 2.2.3 优化
f[i,j] = Max(f[i-1,j], f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)
f[i,j-v]=Max(f[i-1,j-v], f[i-1,j-2v]+w,..., f[i-1,j-(s+1)v]+(s+1)w)

二进制的优化方式
s=1023

1,2,4,8,...,512

0~1023
> 把多种背包某个物品有s次，转化为logS的物品的01背包问题，因此可以拼凑出问题的解

注意这里的凑数，最后一个是剩余的解
如 s=200
1,2,4,8,16,32,64,73

1~127
    73~200
所以只凑出了0-200的解

s
1,2,4,8,..,2^k,c
c=s-(2^{k+1}-1)

c<2^{k+1}
s<=2^{k+2}-1;

优化步骤
总物品数：NlogS
时间： VNlogS

## 2.3 分组背包问题

### 2.3.1 状态表示
- 集合： 只从前i组物品中选，且总体积不大于j的所有做法
- 属性： Max

### 2.3.2 状态计算
f[i,j]
集合划分,对第i个组怎么操作？

对于第i组，不选，选第1个物品，选第2个物品，..., 选第k个物品

f[i-1,j] , f[i-1, j-v[i,k]] + w[i,k] k

> 用的是上层状态则从大到小枚举，用的是本层状态则从小到大枚举


# 3 线性DP

## 3.1 数字三角形

### 3.1.2 状态表示
f[i,j]
- 集合
所有从起点，走到(i,j)的路径

- 属性： Max

### 3.1.2 状态计算
f[i,j]

集合分类: 往前追溯
来自左上方，来自右下方
> 曲线救国？
> f[i,j] = max(f[i-1,j], f[i-1,j-1]) + a[i,j]
> 下标涉及到i-1，从1开始

时间复杂度：状态数量*转移的计算量 n^2 * 1


## 3.2 最长上升子序列
- 维度选取标准
> 目标：从小到大考虑维度是否合适
### 3.2.1 状态表示
f[i]
集合：所有以第i个数为结尾上升子序列的集合
属性：集合长度的Max
> 关键！一定要把集合说明白和清楚，突然明白了为什么要这么说？

### 3.2.2 状态计算
f[i]： 
集合划分
> 考虑多种划分思想
对上升子序列的集合进行划分，如何讨论

首先，一定把第i个元素放入，那么这个上升子序列的集合是哪个呢？对0,1,2,..,i-1元素进行讨论
aj <= ai, j: 0~i-1   f[i] = max(f[j]+1)
j=0, f[0]=1;

- 时间复杂度
状态数量*转移的计算量, n\*n

> 记录转移位置：为最大值进行标记
> 这里的感觉是潜在的状态转移方程的感觉

### 3.2.3 优化
考虑求的过程是否有某种性质？在计算过程中是否有重复计算
k:1 2 3 4 5 6 7
a:3 1 2 1 8 5 6

思考3和1的情况，凡是能接到3后面的序列，一定可以接到1后面

所以考虑换个角度，即对每个长度，存储索引k小的位置
随着长度增加，结尾的值一定是单调递增的

> 目标：找某个衡量值的单调性，比如这里的ai的单调性。一旦有了单调性就可以进行存储，就可以用二分法来做，就会大大地提升速度。

> 直接将ai更新到q就可以

从某种程度上更像贪心一点！
nlogn

直接求解问题
## 3.3 最长公共子序列
从两个长度为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串最长子序列

### 状态表示
f[i,j]

集合：所有由第一个序列的前i个字母和第二个序列的前j个字母构成的最长公共子序列

属性： Max

### 状态计算
f[i,j]
集合划分
标准，是否选a[i],b[j]
> 
00  f[i-1,j-1]
01  f[i-1,j-1]+1 : 以b[j]结尾
> f[i-1,j] 不代表这种情况，因为b[j]不一定为结尾
> 01 包含在f[i-1,j]中， f[i-1,j]包含在f[i,j]中
10
> f[i,j-1]
11  f[i-1,j-1] + 1

> 然后我们可以用f[i-1,j],f[i,j-1]替换01， 10； 此时这两种情况与00会有重叠，但是没有关系
> 因为包含了f[i-1,j],f[i,j-1]包含了00， 所以一般就不写f[i-1,j-1]这种情况
> 因为max是不需要分开的部分独立的，比如求三个数的最大值，max(a,b,c)=max(max(a,b),max(b,c)), b用了两次

int a+1; abcd拼成的整数的存储


## 3.4 最短编辑距离
- 状态表示
f[i,j]
集合：所有将a[1~i]变到b[1~j]的操作方式的集合,  操作方式有插入、删除、替换
属性：集合的长度的最小值

- 状态计算
f[i,j]
集合划分 
可以从集合的最后一步考虑:
    - 删除， a[1,i-1]与b[1,j]匹配    len(a)=len(b)-1, 但是这里是动态变化的，所以没有必要进行这个当前len的判断，f[i-1,j]+1
    - 添加一个新字母， a[i+1]=b[j], 添之前a[1,i]与b[1,j-1]匹配 len(a)=len(b)+1 f[i,j-1]+1
    - 改， a[i]!=b[j], f[i-1,j-1]+1

时间复杂度 n^2 *3

> 动态规划是暴力的优化，用内存存储了一些需要计算的内容，不再需要暴力枚举每一个。但还有优化的空间，什么呢？就是没有保证某个计算只是一个
# 4. 区间DP

## 4.1 石子合并
一堆石子，每次合并都会包含一定的代价，问如何合并，体力消耗最小；
类似于大整数相乘的感觉

### 状态表示
f[i,j]: i,j表示的区间的开始长度和结束长度

集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式

属性：Min, 合并方式的代价的最小值

### 状态计算
f[i,j]

集合划分
以最后一次合并的分解线来合并

左边k-i+1，  右边j-k+1
[i,k], [k+1,j]

f[i,j] = max_k (f[i,k]+f[k,j]+pj);
k=i,..,j-1

> 前缀和，来表示区间和
时间复杂度： n^2 n  300^3=2.7*10^9

每次可以合并m堆
目标是枚举一次合并，用暴力，C_k^{m-1}堆， 总共有m-1个划分位置
> 问题其实可以进一步转化为将一个区间分为m份，如何划分最优，使用dp来做，g(i,j)将前i个数分为j组的最小代价 n^3 *m


> 注意计算的顺序，计算方式所依赖的状态应该先计算出来才行

> 动态规划有两个写法： 递归方式的学名叫记忆化搜索，循环方式为常见写法，会快一个常数
> 区间长度的DP一般循环方式有两个，一个
动态规划用一个状态表示一堆状态的集合， dfs遍历的则是每一个状态；

C++一般可以算10^7, 10^8

# 5. 计数类DP

> 属性是数量

## 5.1 整数划分问题
### 解法1
无序的
物品：n
物体的体积：1,2,..,n
每个物品可以放任意次
-> 完全背包问题
把复杂的问题转化为简单的已知的问题

- 状态表示
集合：所有从1~i中选，和恰好是j的集合
属性：数量
- 状态计算
i-1 选多少个  j=n
f(i-1,j)+ sum_k f(i-1,j-k*i)
即： f[i,j]=f[i-1,j]+f[i,j-v[i]]

时间复杂度
当体积是i是，k=n/i
k1+k2+...+kn = lnn+c;  时间复杂度为 nlogn

进一步简化
注意这里属性是长度，所以
f[j] = (f[j]+f[i-j]) mod p; 
这里就直接是相加，也就是为什么需要分类互斥了

### 解法2
f[i,j]
集合：所有总和是i，并且恰好表示为j个数的和的方案
属性：数量

集合划分
最小值是1 f[i-1,j-1]
最小值大于1 f[i-j,j]
> 这里不是考虑这个最小值为多少，而是不断去逼近这个最小值 f[i-j,j] 将每个数都减1,其方案数应该一样
f[i,j] = f[i-1,j-1] + f[i-j,j]
ans=f[n,1]+f[n,2]+f[n,3]+...+f[n,n]

# 5. 数位统计DP

## 5.1 计数问题
统计两个整数数位之间0~9的出现次数
数据范围 0-1e8
> 小学奥数问题

分情况讨论
[a,b] 0~9

count(n,x) 1~n中x出现的次数

count(b,x)-count(a-1,x)
> 当问题区间不好求时，经常的一种思路就是使用前缀和的思路

分别求出1在每一位上出现的次数

求1在第4位上出现的次数
1<= xxx1yyy <= abcdefg

按前3位取值来分类的：
1) xxx=001~abc-1, yyy=000~999, *1000
2) xxx=abc 
    d<1, abc1yyy>abc0efg, 0
    d=1, abc1,  yyy=0~efg,  efg+1
    d>1, abc1,  yyy=0~999, 1000

所有情况 abc*1000 + 0 + efg+1 + 1000 = (abc+1)*1000 + efg+1

因此可以求出1在任意一位出现的次数

时间复杂度：10组数据，每组2个数，每个数有8位，最多循环10次

实际例子：
从1~111 0出现的次数

对于111的例子:
1. 统计个位上的0, 十位去01-10 10


# 6. 状态压缩DP

> 状态是一个整数，却要将其看成一个二进制数

## 6.1 蒙德里安的梦想
状态压缩的经典应用

> 可以横着放，也可以竖着放
横着放完后，竖着摆放小方格就确定了，只有一种情况。所以考虑横着放置的小方格的情况

f[i,j] 现在要摆第i列
j是哪一列申出了小方格
j 0~31, 5位二进制数？？？

这里是状态，所以就是数量进行相加

每一种选取都是一种方案数，下一个状态加上现在的状态所以就构成了问题的最后的结果，并且保证每次的状态都是一定的

> 检查，先看状态是否是对的！这种做法很优秀！！


## 6.2 最短Hamilton路径

0~n-1, 从0到n-1不重不漏地恰好经过每个点一次

n!n
> 乘以路径的长度，为什么是n？
20! * 20 时间复杂度非常高

跟上个题一样，用一个整数表示一个状态

f[i,j]

- 状态表示
集合：所有从0走到j，走过的所有点的状态是i的所有路径的长度
> i是二进制数，表示所有点的状态数
> 0到j，j是具体哪个点的标号

属性：Min

- 状态计算
f[i,j]
集合划分
倒数第二个点来分类
0->k->j
f[i,j] = min_k f[i-{j},k] + a[k][j]


> 这里为什么用状态压缩，而没有用其他情况来做，因为这里的走到j节点，不一定从小的点走到，可能从更多的大的点走到

# 7. 树形DP

## 7.1 没有上司的舞会

f[u,0]
集合： 所有从以u为根的子树中选择，并且不选u这个点的方案
f[u,1]: 所有以u为根的子树中选择并且选择u这个点的方案

属性： Max

u-> s1,s2
f(u,0) = sum_s max((f(s1,0), f(s1,1))
f(u,1) = sum_s f(s1,0)  + a(u)
> 这里sum 实际上求的就是边，所以计算量就是枚举所有的边，而对于树的所有边之和为n-1.
即u的范围为n-1, 每个单位为2， 即为常数 
因此复杂度为O(n)

> 树形DP的感觉就是，其实关心还是两个状态之间的关系，不过这里的状态转换为了树。
考虑当前与上一节点的关系，就相当于考虑父节点与子节点之间的关系

# 8. 记忆化搜索

## 8.1 滑雪

- 状态表示
f[i,j]
所有从(i,j)开始滑的路径

Max
- 状态计算
f[i,j]
按第一步开始滑的路径
按方向分 f[i,j]
i,j -> i,j+1
f[i,j+1]开始滑的最大长度  

> 拓扑图，不能成环； 怎么判断实际的情况？

注意到记忆化搜索代码很有意思


# 其他

时间复杂度
空间复杂度
代码复杂度: 记忆化搜索