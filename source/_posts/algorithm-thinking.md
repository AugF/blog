---
title: algorithm-thinking
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 08:49:01
tags:
- algorithm
- thinking
categories:
- [algorithm, thinking]
---

## v2

>1. C++ STL
>2. 数据结构基础
>3. 图
>4. 暴力求解法
>   - 简单枚举
>   - 回溯法
>5. 高效算法设计
>6. 动态规划初步
>7. 数学概念与方法
>8. 图论模型与算法
>9. 高级专题
>

### 4. 暴力求解法

#### 4.1 简单枚举

> 一般来说，也需要对问题进行一定分析。从多个角度入手分析最小的枚举范围。

#### 4.2 枚举排列

```
*S
*A
main(){
S={1,2,..,9}
A=""
print_permutation(A,S);
}

print_permutation(A, S){
	if(S==null){
		print A;
	}
	else {
		for v in sorted(S):
			print_permutation(A+"v",S-{v});
	}
}

在具体中的运用，比如C++
数组A，不具有长度信息，同时可以考虑用临时变量
```

考虑生成可重集的排列

> tips: 比如S中A出现的次数是否用完

- 排列子集生成

n!

> 怎么输出一棵解答树：
>
> n
>
> *a
>
> ```
> print_tree(t){
> 
> if (t>n) {
> 
> ​	printf(X)
> 
> } else {
> 
> for(int i=t;i<=n;i++){
> 
> ​	swap(x[i],x[t]);
> 
> ​	print_tree(t+1);
> 
> ​	swap(x[i],x[t]);
> 
> }
> 
> }
> 
> }
> ```
>
> 

下一个排列：

枚举排列常见方法有两种：一是递归枚举，二是用STL中的next_permutation.

#### 4.3 子集生成

- 增量构造法

  > 实现规定A中的集合按升序排列好。
  >
  > for循环的理解还不到位，阅读代码能力还有待加强。

  ```
  void print_subset(int n, int* A, int cur) {
      for(int i = 0; i < cur; i++) printf("%d ", A[i]); // 打印当前集合
      printf("\n");
      if()
      int s = cur ? A[cur-1]+1 : 0; // 确定当前元素的最小可能值
      // 下一个元素一个是当前的前一个元素加一，并开始排列。否则就为0；隐含地处理了cur为0，无A[cur-1]的情况
      for(int i = s; i < n; i++) {
          A[cur] = i;
          print_subset(n, A, cur+1); // 递归构造子集
      }
  }
  
  n=4
  0
  0 1
  0 1 2
  0 1 2 3
  0 1 3
  0 2 3
  0 3
  1
  1 2
  1 2 3
  1 3
  2
  2 3
  3
  
  在枚举子集的增量法中，需要使用定序的方法，避免同一个集合出现两次。
  
  可以发现这个框架不适用，特别是当子集不是给定的自然数，而是给定的集合时。
  
  改进版
  
  S=sorted(S)={0,2,3,4}
  n=len(S)
  print_subset(n,A,S,0,0)
  print_subset(n,*A,S,cur,s){
  	// 不需要界，中间过程也用于输出。
  	for(int i=0;i<cur) print(A[i]);
  	printf("\n")
  	// 
  	for(int j=cur;j<n;j++) {
  		A[cur]=S[i];
  		print_subset(n,A,S,cur+1,i+1);
  	}
  }
  // 可用树来直观检验和表示循环的结构。
  // 还有测试时，作为一般递归函数，在i=0,1,2就有表示了。
  ```

- 位向量法

  > 位向量法其实更适合表示即给定子集，并且子集元素非自然数那种。

  ```
  并非构造子集A本身，而是构造一个位向量B[i],其中B[i]=1,当且仅当i在子集A中
  *B
  void print_subset(n,B,cur){
  	if(cur==n) {
  		for(b in B):
  			if(b) printf(b);
  		printf("\n");	
  	}
  	else{
  	// 两种情况，直接枚举
  		B[cur]=1;
  		print_subset(n,B,cur+1);
  		B[cur]=0;
  		print_subset(n,B,cur+1);
  	}
  }
  ```

- 二进制法

  > 突发奇想，想到二进制数的表示方法为 1<<n， n个1就为 1<<(n+1)-1；
  >
  > 对于位运算，其实考虑的就是数组的两个元素可能做哪些运算（在0,1层面上）？
  >
  > 基本上就三种：
  >
  > 1.  检查该位的状态，用与&
  > 2. 将该位置1。考虑用或|，或者加上一个数（速度慢）
  > 3. 将该位置0。考虑用对称差^，不行的话减去一个数（速度慢）

#### 4.4 回溯法

> 回溯法的关键，根据框架去思考问题。首先把问题转变为子集树或者排列树。然后找对应的约束。

- 八皇后问题

> 第一种方法：从64个格子中寻找子集或者寻找八个满足的格子。分别对应于三个约束。
>
> 位置+二维就可以形式化为排列数，这样就去掉了两个条件
>
> 限制条件为，[i,x[i]]。从某种意义上只需要和上一个元素比较是否在斜线上。就是两点斜率的绝对值为1
>
> ```
> *x = {1,2,..,8}
> 
> search(t){
> 	if (t > n) {
> 		printf("sucess")
> 	}
> 	else {
> 		for(int j=t;j<=n;j++){
> 			
> 		}
> 	}
> }
> ```
>
> 这样有点太定势思维了，最重要的是掌握回溯法的精髓，即只需要状态的前进和恢复。
>
> ```
> v1: 因为这里分析出来是排列，那么可以考虑只是行被排除了。如果走到递归边界。
> 首先，从初试节点开始，每个值都可以取，然后检查现在的每个节点所取的值是否与之前节点的值冲突。如果没有冲突，递归执行。
> 
> v2: 没选中一个节点，对该节点周围的所有节点进行染色；所以当前仅当这些点没被染色，才可选这些节点。
> ```

- 判断素数环

  > 法一、使用生成-测试法。即先将素数生成好，然后再判断是否为素数。生成所有的排列，然后测试所有的排列是否满足情况
  >
  > 法二、使用回溯法，但是值得注意的是在这里直接使用会所。然后判断每个元素
  >
  > > 由此也可以看出，对于生成测试法，时间复杂度就是所有情况；而对于回溯法可以去掉很多情况。所以当最坏情况的枚举量很大时，应该考虑采用回溯法而不是生成-测试法。
  >
  > ```
  > 回溯法
  > int dfs(int t){
  > 	if(S==null){ // 递归到达最后一层
  > 		print A;
  > 	}
  > 	else {
  > 		// 这里for循环对应于子树的个数
  > 		for v in sorted(S): // 对于众多的变形，就是很多限制排除掉一些不可能的情况
  > 			print_permutation(A+"v",S-{v});
  > 	}
  > }
  > ```

- 困难的串

- 带宽

- 天平难题

#### 4.5 路径寻找问题

#### 4.6 迭代加深搜索

### 5. 高级篇

- 再谈排序与检索
- 递归与分治
- 贪心法
- 算法设计与优化策略
- 动态规划初步
- 数学概念与方法
- 图论模型与算法

#### 5.1 算法分析设计初步

一种直觉的柑橘