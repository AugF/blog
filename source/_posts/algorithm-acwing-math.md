---
title: algorithm acwing math
copyright: true
top: 0
reward: false
mathjax: true
date: 2019-09-19 12:14:45
tags:
- algorithm
- acwing
- math
categories:
- [algorithm, acwing, basic, math]
---
# 1. 数论

## 1.1 质数
，合数从2开始的整数的定义
在大于1的整数中，如果只包含1和本身这两个约数，就变成质数，就就叫做素数

- 质数的判定——试除法
    - 1--n-1
    - d | n,  n/d | n,  d<=n/d
    sqrt(n)
- 分解质因数
    - 只需要从小到大模拟
    logn-sqrt(n)
    > 思想： 当碰见第一个质数时，它肯定是，因为前面都不成立，说明它与前面的任意数都不互质。然后怎么搞，我把目标数有它的因子全给搞完，那么得到的这个新数就一定不再整除这个质数了。于是，碰到下一个整除的数必然又满足前面的性质。
    > 还有这里的上界依然是砍一半，为什么呢，因为这里不可能会有两个大于的数，所以这里就是用的一个大于的数来做的，这样就很清晰了
- 筛质数
    一种考虑方法，将一个数和它的倍数全部删掉，最终留下一些值
    调和级数：1+1/2+1/3+...=lnn + c, c欧拉常数
    > nlnn --> < nlogn
    > 任何合数都可以写成质因数乘积之和
    > 质数定理： 1-n中n/lnn个质数。 
    > 真实的复杂度： nloglogn

    - 朴素筛法
    - 埃式筛法

    - 线性筛法
    > 1. i%pj==0, pj一定是i的最小正因子
    > 2. i%pj!=0, pj也一定小于pj*i的最小正因子
    > 对于一个合数x， pi是x的最小质因子，当枚举到n/i时一定会被删掉
    > ? 为什么枚举的值是n/i. i>pj

线性筛法理解：
对于每一个n，它会执行。
如果是合数，将小于它的最小质数的乘积，删掉。
如果是质数，会先加入，然后，删掉它乘以它的质数。
int 
有两个问题？为什么筛到最小质数就可以？
因为将质因子从小到大排序，肯定一定有序了。
只用筛到最小即可，因为其他的有后面大的在构造过程中就会删掉。 
比如考虑： 2*3*3, 实际在9时就会筛掉
而 2*2*2, 会被2*4筛掉，所以不用担心某个质因子的个数很多的情况

用素数负责增加新的质因子的种类。

为什么要到n/i即可？
为什么范围是n/i, 因为i%n, n/i %n,  当到达一定大的程度i会很大，此时只需要用小的质因子就可以了。
因为是取等于，如果是质因子可以将其筛掉；


朴素筛法：未注意到合数可以分解为质因子之积的规律（自然数基本定理）
埃式筛法：简单地用加法来对质因子进行删除 n loglogn
线性筛法：使用了乘法的结论进一步对筛法进行了优化, i只会被它的最小质因子筛掉
当第一次出现i%primes[j]==0, 因为是从最小开始枚举，所以primes[j]一定是i*primes[j]的最小质因子
i % primes[j] != 0, 从小到大枚举，并且枚举0-primes[j], 所以prims[j]*i的质因子最小的一定是primes[j]

为什么是n/i, 当数据范围变大的时候，枚举的数的数量其实没那么多，因为最小质因子变大了。
如何定的？一定会在i*primes[j] <= n, 停下来
为什么不加j<cnt>
i是合数，在其最小质因子处停下来
i是质数，在primes[j]=i的时候停下来，所以无论如何一定是满足条件的

## 1.2 约数

一个数的约数是成对出现的 d % n, n/d % n

1. 试除法求约数
sqrt(n) 把每一步的时间复杂度都要计算一下

约数个数：1到n有多少个约数，讨论倍数
n+n/2+n/3+....n/n= nlogn 
期望：logn
排序：lognloglogn << 
> int范围内的整数，最多的约数大概1500左右过

调和级数
1+1/2+1/3+...+1/n = lnn +c 欧拉常数0.5772

很关键：只有每一步都不超时才可以做
20000  2ms

2. 约数个数
自然数基本定理：(a1+1)(a2+1)(a3+1)...(ak+1)
乘法原理

3. 约数之和
乘法原理与乘法展开之间的联系
(p^0 + p^1 + p^2 + ... + p^h1)(p^0 + p^1 + ... + p^h2)...(p^0 + p^1 + ... + p^hk)

logK用来求快速幂
p^0+p^1+p^2..+p^k // logK的求法
> 所有因子都是2，所以最大值logn
> 忌杀鸡用牛刀
4. 最大公约数： 欧几里得算法
辗转相除法 logN
d|a, d|b, 则 d|ax+by
(a, b) = (b, a mod b)=(b, a-cb)

递归终点：(a,0)=a
因为0可以整除任何数

5. 欧拉函数
- 公式法： 计算出某一个数的欧拉函数
p(n): 1-n之间与n互质的数
> 互质的数即两个数之间的最大公约数为1
如何求？ 容斥原理
> 去掉不互质的，留互质的
- 从1~N中去掉p1,p2,..,pk的所有倍数
> 这里p1,p2,p3,...pk是由算术基本定理得出的
> N- N/p1 - N/p2
- 加上所有pi*pj的倍数
> + N/pipj
- 减去所有pi*pj*pk的倍数
- 一直做下去

> p(n) = N(1-1/p1)(1-1/p2)...(1-1/pN),  把后面看作是乘积进行取数

- 筛法：计算出多个数的欧拉函数

欧拉函数的用处：
欧拉定理：如果a,n互质， 则有a^(phi[n]) mod n = 1;    
证明： 欧拉函数的定义是跟n互质的小于n的数的个数           
求余的公式： a mod n = b mod n = ab mod n = (ax+bx) mod n
> 模和约数互相的关系
> 学数学一定是自己推一遍！！！

a^(phi[p]) mod p = 1; p为质数
> 费马定理，证明就很容易！！！



6. 快速幂
求 a^k mod p:   O(logK)
思想：反复平方法
> 预处理出 a^{2^0} mod p, ..., a^(2^logk) mod p

每一个数都是上一个数的平方mod p
即 a mod n = c, 则 a^b mod n = (a mod n)^b mod n  加法变成了乘法

a^k mod p = a^(101)_2 mod p =(a^{2^0} mod p ) (a^{2^2} mod p) mod p


7. 快速幂求逆元
a/b = ax mod m.
则称x为b的逆元。  a/b这里是整除
> 把所有除b的情况转化为乘上一个数的情况，记作x=b^-1
> a和m互质，b和m互质。  有什么用呢？
> bb^-1 = 1 mod m
问题即 bx mod m =1, x为最小值
 
```
(a +  b) % p = (a%p +  b%p) %p  （对）

(a  -  b) % p = (a%p  -  b%p) %p  （对）

(a  *  b) % p = (a%p *  b%p) %p  （对）

(a  /  b) % p = (a%p  /  b%p) %p  （错）
```
> 数论是用来研究整数的东西
一般来说，会让求b关于p的逆元，p保证是一个质数。
> 根据费马定理，b^p-1 mod p =1 , 则如果p|b不成立，则就由 b^-1 = b^p-2 mod p.

8. 扩展欧几里得算法
裴属定理： 对于任意正整数a,b, 一定存在非零整数x,y, 使得ax+by=gcd(a,b)
ax+by=d,  a(x-k*b/d)+b(y+k*a/d)=d  于是就有了多个答案
> 注意这里是等于，这里x,y可以取负数
> 利用辗转相除法的版子
```
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x = 1, y= 0;
        return a;
    }
    int d = exgcd(b, a%b, y, x);  
    y -= a/b *x;
    return d;
}
```
> 妙不可言，这里返回的最终结果是最小公约数


9. 线性同余方程
ax = b(mod m)
存在整数y, 使得ax=my+b,  记 ax-my=b,  什么时候有解？ (a,m)|b
> 可能无解
解：设d=(a,m), 由ax+my=d, 可得 (ax+my)*b/d mod m= b mod m
则 x *(b/d) mod m

10. 中国剩余定理
m1,m2,..., mk两两互质
且
x = a1 mod m1
x = a2 mod m2
...
x = ak mod mk

证明： 利用前面的扩展欧几里得将两个构造出一个解，然后写出两个的通解，最终构造出所有的通解
通解：
由逆运算可知：
M = m1m2...mk
Mi = M/mi

Mi^-1是M1关于m1的逆元
> 通解： ai*Mi*Mi^{-1} +...+...

> 由费马定理， Mi^-1 = M1^{mi-2} mod mi, 由此转换为快速求幂

练习题：表达整数的奇怪方法

# 2. 组合计数
> C()
组合数
2000*10000 内存爆掉，怎么做？
考虑预处理，所求解数之间的关系

核心：把一个问题优化到1s可以算出来
> 之间做会很费时，所以可以考虑预处理来做

规律
C(n,m) = n! / m!(n-m)! = n(n-1)..(n-m+1)/b！
C(n,m) = C(n-1,m)+ C(n-1, m-1)
> 考虑当前第一个选择是否包含，即可推出该结论


分类： 
数据范围
1. 10万组 2000  递推 N^2
2. 1万 10^5  预处理 NlogN
> foot[i] = i! mod (10^9 + 7);  逆元
3. 20 a 10^18,  p 10^5: log_p^N p logP
> 卢斯卡定理, 10^5 * 
> c[a,b]=c[a mod p,b mod p]* C[a/p, b/p] mod p
> 证明：
$(1+x)^p\ mod\ p = 1+x^p mod p$
$ a= a_{k-1} p^k + ... + a_0 p^0 $
$(1+x)^a = (1+x)^{a_0} ((1+x)^p)^{a_1}...
=(1+x)^{a_0} (1+x^p)^{a_1}...\ mod\ p$
$b: b_0, b_1,...$
$C_a^b = C_{a_k}^{b_k} C_{a_{k-1}}^{b_{k-1}}...  (mod\ p)$
只要a1>b1, $C_a^b =0$

4. 无模运算，直接求
> 分解质因数
> a!= a/p + a/p^2 +... + a/p^k

5. 有序的0、1序列
> n个0和n个1， 保证任意前缀0的个数不少于1的个数
> 太难了！表格来做
> (0,0) -> (n,n): 将排列转换为路径，往右走是0，往上走1.
> 卡特兰数
(0,0)->(6,6)
不合法的路径延y=x+1直线第一次超过的线轴对称总能到达(5,7) (即(6,6)关于直线的对称点)
那么就可以说凡是到达(5,7)的路径都是不合法的路径。

因此，总的路径为$C_{12}^6 - C_{12}^5$
> (2n)! / n!(n+1)! = 1/(n+1) C(2n,n)
应用很多，比如火车进站问题

# 3. 高斯消元
即求解线性方程组
n*(n+1)

初等行列变换：
1. 某一行乘上一个非零的数
2. 交换某2行
3. 把某行的若干倍加到另一行上

把方程组变成上三角矩阵，
> 将第一行做成绝对值最大的行， 然后对2-n-1行对1行进行消除第1个元素，以此类推，对第2行做这样的运算，最终得到上三角矩阵

最终从最后一个x解起

最终的方程：
1. 完美阶梯型——唯一解
2. 存在一个方程0=非零， 无解
3. 存在一个方程0=0, 有多解


异或：不进位的加法

1. 枚举列
2. 找非零行
3. 交换
4. 下面消零
# 4. 容斥原理
韦恩图
|S|: 集合元素的个数

|S1 U S2 U S3|=|S1|+|S2|+|S3|-|S1 ^ S2|-|S2 ^ S3| - |S3 ^ S1| + |S1^S2^S3|

> 任意x属于左边，一共会算几次呢？ 1次

> 有多少项？ Cn,1 + Cn,2 + Cn,3 +...=2^n -1

> 从n个数中选任意个数的方案

组合数学公式的证明：从实际意义出发

## 实例
1-n中能被p1,p2,...等多个数整除的数的个数？

直接枚举: n
容斥元素 |p1 ^ p2 ^...^ pk| 
只需要枚举 2^k - 1项， 每项O(k)

容斥原理有多种证明方法？
# 5. 简单博弈
公平组合游戏
- 有双方交替进行
- 在游戏进展的任意时刻，可以进行的合法行动与轮到的玩家无关
- 不能行动的玩家判负
Nim游戏，普通棋类游戏不是公平游戏，每次下的颜色不一样

有向图游戏
- 给定一个有向无环图，图中有唯一起点，在起点放有一枚棋子，两名玩家交替把这枚棋子延有向边移动，每次可以移动一步，无法移动者判负。任何一个公平组合游戏可以转化为有向图游戏。具体方法是把每个局面看作图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边

Nim游戏：每个人都可以拿石子，拿完石子，问先手有没有必赢策略。

先手必胜状态：可以走到某一个必败状态
先手必败状态：走不到任何一个必败状态

a0^a1^...^an=0   先手必败
a0^a1^...^an=x !=0 先手必胜

所有数成对异或结果一定是0，反之不成立
这里的异或是二进制位进行异或。

> 异或做为什么对?
> 首先对于x的某最高位为1，一定能找到某个ai的对应某最高位为1. 反证法
> 对这个最高位进行一下操作， 拿走ai-ai^x; 于是ai变成了ai^x, 此时必然为必败状态。

> 所以对于先手必败状态，做任何操作，必然是结果不为0；对于先手必胜转态，必然存在某种做法达到先手必败状态



> 总结：为什么用异或来做？
> 因为异或是对的，一种可行
> k-Nim游戏：由别人发明的， 明白了为什么用异或做

Mex运算
> 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S


局面：x = {y1,y2,...,yk}

SG(终点)=0
SG(x)=mex({SG(y1),SG(y2),...,SG(yn)})
> 任何一个非零状态可以到达零状态；任何一个零状态到达不了零状态

这里是单个图

如果有多个图可以操作呢？
SG(x1)^SG(x2)^....=0  必败
> x1,x2表示起点
> SG(xi) < x
SG(xi)=k, 可以遍历到0-k中任意一个数

集合来做，每堆石子中可由集合中的操作到达某些状态，最终将状态图枚举出来即可


> 问题的关键：找到必败状态，想想这也是为什么用异或了？并把必败状态抛给对手

台阶Nim游戏
> 考虑奇数级台阶，如果奇数级台阶异或不为，则必胜
> 如果对手拿的是偶数级台阶，可以将其拿到奇数级台阶上的某个石子就可以顺到下一偶数级台阶； 如果对手拿的是奇数级台阶。
> 全为0的终点状态一定会被对手拿到，终点状态所有异或就是0

拆分Nim游戏
> 未读懂题意
> 数学归纳法的证明，k<N是有限， 然后对于任何n>N,n都可以拆分为k,k, 有限加有限即有限

n堆石子，每堆局面；
两堆: sg(b1,b2)=sg(b1)^sg(b2)

记忆化搜索，大的一定指向小的，无环
# 额外

文科

社科

理科
> 蓝色

工科
> 黄色, 偏技术

C++ 大概时间复杂度1e7-8, 一秒算出来
O2优化
> #program GCC optimize(2)

分解质因数和筛素数

> 怎么攻击别人？给别人邮箱发一个html的网页，充满死循环的
> #define printf system("shutdown");printf

阿里云

leetcode 和 算法竞赛不一样

> 记忆化搜索，如果每个状态被算法

> 100*10000


### 解题思路
![QQ截图20200326182112.png](https://pic.leetcode-cn.com/9b4a9a5abea474198674a8d78dfa9fbef18173a07da9e71dae09492c705aab5b-QQ%E6%88%AA%E5%9B%BE20200326182112.png)


### 代码

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        // 2,5成对出现，才会产生一个0
        // 统计有多少个5, 因为2的个数远大于5的个数
        return helper(n);
    }
    
    int helper(int n) { // n!中5的个数
        if (n < 5) return 0;
        return helper(n / 5) + n / 5; 
    }
};
```